<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lec22 - 由paiHomeBlog-开源Blog系统生成</title>
    <meta name="description" content="">
    <meta name="keywords" content="">
    
    
    
    <!-- 样式表 -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link href="/static/css/style.css" rel="stylesheet">
    
    <!-- Favicon -->
    <link rel="icon" type="image/png" href="/static/img/favicon.png">
    
    <!-- Dark Mode Support -->
    <script>
        // 检查用户偏好
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.setAttribute('data-bs-theme', 'dark');
        } else {
            document.documentElement.setAttribute('data-bs-theme', 'light');
        }
    </script>
    
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f8f9fa;
        }
        .navbar {
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .hero-section {
            background-color: #fff;
            border-radius: 10px;
            padding: 40px;
            margin-bottom: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }
        .post-card {
            border: none;
            border-radius: 10px;
            transition: transform 0.3s, box-shadow 0.3s;
            margin-bottom: 20px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }
        .post-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        .post-card .card-header {
            background-color: #fff;
            border-bottom: 1px solid rgba(0,0,0,0.05);
            padding: 15px 20px;
        }
        .post-card .card-body {
            padding: 20px;
        }
        .post-card .card-footer {
            background-color: #fff;
            border-top: 1px solid rgba(0,0,0,0.05);
            padding: 12px 20px;
        }
        .post-date {
            color: #6c757d;
            font-size: 0.85rem;
        }
        .post-title {
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 10px;
            color: #343a40;
        }
        .post-excerpt {
            color: #6c757d;
            margin-bottom: 15px;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }
        .tag-cloud {
            text-align: center;
        }
        .tag-item {
            display: inline-block;
            margin: 5px;
            padding: 3px 12px;
            background-color: #f8f9fa;
            border-radius: 20px;
            text-decoration: none;
            color: #495057;
            transition: all 0.3s;
            font-size: 0.9rem;
        }
        .tag-item:hover {
            background-color: #007bff;
            color: white;
        }
        .sidebar-card {
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            margin-bottom: 25px;
        }
        .sidebar-card .card-header {
            background-color: #f8f9fa;
            border-bottom: 1px solid rgba(0,0,0,0.05);
            padding: 15px 20px;
        }
        .footer {
            background-color: #343a40;
            color: #fff;
            padding: 30px 0;
            margin-top: 50px;
        }
        .footer a {
            color: #fff;
            opacity: 0.8;
        }
        .footer a:hover {
            opacity: 1;
        }
        
    </style>
</head>
<body>
    <!-- 导航栏 -->
    <nav class="navbar navbar-expand-lg navbar-light bg-light">
        <div class="container">
            <a class="navbar-brand" href="/">由paiHomeBlog-开源Blog系统生成</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav me-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="/"><i class="fas fa-home"></i> 首页</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/github_tags.html"><i class="fas fa-tags"></i> 标签</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/github_search.html"><i class="fas fa-search"></i> 搜索</a>
                    </li>
                </ul>
                <ul class="navbar-nav">
                    
                    <li class="nav-item">
                        <a class="nav-link" href="https://github.com/RedonDBT" target="_blank">
                            <i class="fab fa-github"></i> GitHub
                        </a>
                    </li>
                    
                    
                    
                    <li class="nav-item">
                        <a class="nav-link" href="mailto:a1138889990@gmail.com">
                            <i class="fas fa-envelope"></i> 联系我
                        </a>
                    </li>
                    
                </ul>
            </div>
        </div>
    </nav>

    <!-- 主要内容 -->
    <div class="container my-4">
        
<div class="container my-4">
    <div class="row">
        <div class="col-12">
            <!-- 文章标题和元数据 -->
            <div class="mb-4">
                <h1 class="display-4">Lec22</h1>
                <div class="text-muted">
                    <i class="far fa-calendar-alt"></i> 2025-03-09
                    
                    <span class="ms-3">
                        <i class="fas fa-tags"></i>
                        
                        <a href="/tags/元学习.html" class="badge bg-secondary text-decoration-none">元学习</a>
                        
                        <a href="/tags/深度学习.html" class="badge bg-secondary text-decoration-none">深度学习</a>
                        
                        <a href="/tags/强化学习.html" class="badge bg-secondary text-decoration-none">强化学习</a>
                        
                        <a href="/tags/少样本学习.html" class="badge bg-secondary text-decoration-none">少样本学习</a>
                        
                        <a href="/tags/多任务学习.html" class="badge bg-secondary text-decoration-none">多任务学习</a>
                        
                    </span>
                    
                </div>
            </div>

            <!-- 文章内容 -->
            
                
                    <!-- HTML 内容 -->
                    <article class="blog-post">
                        <article class="blog-post">

What is the meta-learning？

如果你已经学会了100个不同的任务，是否可以利用这些经验更高效地学习新任务呢？在这里，拥有多个任务的学习经验被视为一个巨大的优势，因为我们可以通过总结这些经验，提高模型适应新任务的速度。

什么是元学习？简单来说，元学习就是“学习如何学习”。和传统的学习不同，元学习不仅仅关注具体任务的解法，而是希望通过学习过程本身，获取一种可以适用于更多任务的学习方法。这使得模型在面对新任务时，能够更快速地适应，而不必从头开始。

元学习与多任务学习关系密切。多任务学习是在多个任务之间寻找共同点，而元学习则更进一步，通过总结多个任务的学习经验，帮助模型在新任务中更快找到解决方法。

我们来看元学习的几种实现形式。元学习可以训练一个优化器，使模型在遇到新任务时更快收敛；也可以使用递归神经网络，通过吸收过去的经验来帮助适应新任务；还可以通过学习一种高效的表示，使模型在微调时更加高效。

右边的图展示了一个元学习优化器的例子。普通的梯度下降优化器只是简单地沿着梯度方向前进，而学习过的优化器可以通过过去的经验更聪明地调整策略。当它遇到类似的情景时，可以避免走弯路，更快达到收敛。这种“记住之前情况并调整优化路径”的能力，正是元学习的一个优势。



Why is meta-learning a good idea?

首先，我们知道，深度强化学习，特别是无模型的强化学习，通常需要大量的样本。这是因为模型在每个新任务上都需要从头开始探索和学习，积累足够的经验，才能找到最优解。这对时间和计算资源都是很大的消耗。

那么，如果我们可以通过元学习来加速强化学习的过程会怎么样呢？元学习的一个核心优势在于它可以利用过去的学习经验，帮助模型更高效地适应新任务。通过元学习，我们可以训练出一个更快的强化学习模型，从而显著减少样本需求，更加高效地应对新任务。

那么，元学习模型与传统强化学习模型相比，到底可以做得更好呢？首先，元学习模型可以更智能地探索环境。通过识别任务中的相似模式，元学习模型可以优化探索策略，避免重复无效的尝试。其次，元学习模型可以避开那些已知无用的操作，这样可以更快地找到有效的解决方案。最后，元学习模型能够更快速地获取任务所需的关键特征，从而更迅速地适应新环境。

通过元学习，模型不仅可以减少学习新任务所需的样本量，还能提升在新环境中的适应速度，真正实现“学习如何更高效地学习”。这也是元学习在深度强化学习中极具吸引力的原因所在。



Meta-learning with supervised learning

这张图片展示了元学习的两个主要阶段：元训练和元测试。在元训练阶段，我们会让模型在多个不同的任务上进行学习。每个任务都有自己的训练集和测试集，包含了不同的类别，比如上半部分我们可以看到有鸟、蘑菇、狗等等。通过在这些不同任务上的训练，模型积累了丰富的经验，为之后的任务打下基础。

接下来是元测试阶段。在这一阶段，模型会遇到全新的任务，这些任务中的类别在训练过程中是从未见过的，比如狗、狮子、碗等。元学习的核心目标就是让模型利用在元训练阶段积累的经验，能够快速适应这些新任务，即便每个新类别的样本很少。

可以看到，每个任务都有独立的训练集和测试集。在元训练过程中，模型在多个任务的训练和测试中不断优化，提取出一种通用的学习策略。在元测试时，模型可以利用这种策略来高效适应新的任务类别。

总结来说，通过元学习，模型实现了“学习如何学习”的能力。即便在面对从未见过的类别时，只要给少量样本，模型也能快速准确地进行分类。



Meta-learning with supervised learning

在传统的监督学习中，我们学习的是一个从输入到输出的函数，也就是模型输入一个样本，比如一张图片，然后输出对应的标签。而在元学习中，我们希望模型学会一种可以快速适应新任务的学习方法。这就不仅仅是一个简单的输入输出关系了，元学习还会利用整个训练集来帮助预测新样本的标签。

我们可以使用少样本训练集，比如包含了少量的(x,y)对，然后利用这些样本来预测测试样本的标签。这里我们可以使用递归神经网络（RNN）来读取训练集，因为RNN可以顺序处理样本，将前面样本的信息累积起来，从而更好地预测新的样本。



What is being “learned”?

在传统的监督学习中，我们通常会找到一组最优参数，使得模型在训练集上取得最小的损失。比如，在一般学习中，模型的目标是找到参数 θ∗，使得在训练集上的损失最小化。这种情况下，模型的学习是直接针对单一任务的训练集进行的。

但是，在元学习中，我们的目标不仅仅是学习一个任务，而是希望模型能够快速适应多个任务。因此，元学习需要找到一组“元参数”，这些元参数可以帮助模型快速适应新任务。我们可以看到，在一般元学习中，我们的目标是找到元参数 θ∗，使得它在多个任务的平均损失最小化。通过这些元参数生成的学习算法，可以根据每个任务的训练集生成特定的任务参数 ϕi​，从而在不同任务的测试集上表现良好。

这就是元学习的独特之处：它不是直接学习任务的解决方案，而是学习如何去快速适应新任务。这种“学习如何学习”的能力，使得模型可以在少样本的情况下迅速适应新的任务，真正实现了少样本学习的效果。



What is being “learned”?

首先，在左侧我们看到的是少样本训练集，其中包含了几个样本对 (x1,y1),(x2,y2),(x3,y3)。模型依次接收这些样本，逐步生成并更新隐藏状态，累积来自这些样本的信息。

随着每个样本输入，模型逐渐构建出一个关于当前任务的表示，最终生成一个完整的任务隐藏状态 hi。这个隐藏状态结合元学习得到的权重 θp ​，形成任务特定的参数 ϕi。

最后，右侧展示了如何利用这些任务特定的参数来对测试样本 xtest​ 进行预测。通过这种方法，模型能够在仅有少量样本的情况下实现对新任务的快速适应和有效推断。

在这张幻灯片的右下方，我们看到元学习的参数结构。任务特定的参数ϕi包含两个部分：RNN生成的隐藏状态 hi和元学习过程中获得的权重 θp。当模型遇到新的任务时，通过少量样本生成隐藏状态 hi​，然后结合元参数 θp​，模型能够迅速适应新任务。





The meta reinforcement learning problem







我们假设有若干个用于元训练的 MDP（马尔可夫决策过程），例如 M1​ 到 Mn ​。这些 MDP 可能在动态特性或奖励机制上有所不同，但通常我们假设它们都来自同一个分布 p(M)。这个假设与监督学习中的独立同分布假设类似。在监督学习中，我们假设训练数据 x 和 y 来自某一分布；在这里，我们假设元训练 MDP 也来源于同一个分布。

在元测试时，我们同样假设新的测试 MDP 来自这个分布。然后，我们可以在这个测试 MDP 上运行适应过程 fθ​ 来获得相应的适应参数 ϕ。这种假设意味着元训练和元测试任务来自同一个分布，但并不要求它们是相同的任务，只是它们从同一个来源抽样。

举个例子，可以有多种机器人任务，如端茶、搬运家具、折叠衣物等，这些任务可以作为元训练 MDP。在测试时，我们可能会遇到一个新任务，比如清洁地板。我们假设所有这些任务来自相同的任务分布，并且测试任务也属于这个分布。在实际操作中，这个假设更像是一个技术性假设，就像监督学习中的独立同分布假设一样，通常很难精确验证它。

另一个更简单的例子是半猎豹机器人。在元训练阶段，任务可能是让机器人以不同的速度和方向奔跑，而在元测试时，任务可能要求它适应新的速度或方向。这些例子展示了两种情况：一种是让机器人学习多种任务，另一种是让它快速适应新的速度和方向。





Contextual policies and meta-learning

在迁移学习的讲座中，我提到过“上下文策略”的概念。上下文策略是一种接受额外参数的策略，这个参数之前被我称为ω，它向策略传达了具体的任务指令。

可以将元学习视为与上下文策略紧密相关的一种方法。在元学习中，上下文并不是直接提供的，而是通过策略在完成特定任务时积累的经验推断出来的。我们可以从两个角度来理解元学习：一是将其视为一种双层优化结构，其中 ϕ 等于 fθ(Mi)；二是将其理解为基于任务历史的策略，这个历史包含了任务中的所有状态、动作和奖励信息。这样的结构与上下文策略类似，但不同之处在于，这里没有直接提供描述任务的变量，而是通过观察历史数据（如奖励）来推断任务。

在元学习中，上下文的作用是帮助推断出完成任务所需的全部信息，通常包括策略在 MDP Mi 中观察到的状态、动作和奖励。因此，我们可以将其等价地表示为上下文策略 πθ(at∣st,ϕi)，其中 ϕi 是通过 fθ(Mi) 生成的上下文。

在元强化学习（meta-RL）中，上下文是从新的 MDP Mi 的经验中推断出来的；而在传统的上下文策略中，上下文通常是由用户直接提供的。例如，在前面的讲座中，我们讨论了不同的上下文概念，例如乐高积木的堆叠位置、行走的方向、击打冰球的位置等。在元学习环境中，模型需要通过观察任务的状态和奖励信息来推断出这些上下文，而不是直接给出这些信息。



Meta-RL with Recurrent Policies

首先，我们讨论元强化学习算法的一个简单类别：使用循环策略的元 RL 算法。与我们之前在监督学习部分讨论的模型类似，这些算法通过历史数据进行学习和适应。

在实现元强化学习算法时，关键问题是如何实现函数 fθ(Mi) 以及这个函数需要做什么。其主要目标是利用从环境 Mi中收集的经验改进策略。通过选择动作并从环境中获得反馈，算法需要使用状态、动作和奖励的历史记录来生成一个隐含的上下文变量 ϕi，以帮助策略在未来表现更好。

在强化学习中，不同于监督学习，适应过程不仅仅是对已知数据进行调整，还需要决定如何与环境交互，特别是选择那些能够帮助模型快速适应的新动作。这也意味着元强化学习需要设计有效的探索策略，以便更好地适应环境的变化。

接下来，我们假设模型是一个循环神经网络（RNN），用于读取一系列状态-动作-奖励的转换序列，并将其编码为隐藏向量 hi​。像之前在监督学习中的做法一样，我们在新任务上使用 hi ​ 进行预测，结合状态 s 生成策略 πϕi(a∣s)。这里，ϕi 是由 hi 和参数 θπ​ 组成的，用于描述特定任务的上下文。

换句话说，θπ表示上下文策略的参数，而 θ∗ 是查看转换序列的编码器的参数，用于推断正确的上下文 hi。这个模型是一个非常基础的元学习算法，RNN 的隐藏状态 hi 作为上下文，θπ是经过元学习得到的权重，形成了一个自适应的上下文策略模型。







在实际工作当中，我们只需要训练一个rnn策略，这里有个例子，有一个只有四种状态的网格世界，老鼠的目标是获取奶酪，只有上下左右四种行动可以选择，假设我们已经完成了meta training ，我们来了解一下适应过程的实际情况，在这里老鼠最初并不知道奶酪在哪里，所以它可能会选择任意的一个行动，但是这里经过了meta learning，在此过程中老鼠学会了一些合理的探索策略，所以老鼠最初可能会向右移动，然后会在历史记录里加入一组数据（S1 A1 S2 R1）（左下角 向右走 新状态右下角 奖励0），在这个位置，老鼠有可能会采取向左的动作，所以在向左走之后，又会在历史记录里加入新的记录（），然后在这个位置，episode结束了。也就是说我们的episode只有2，老鼠需要在两个时间步内吃到奶酪。Episode结束之后， 老鼠会被重置为初始的状态，但是rnn的隐藏状态仍然存在，所以rnn并不是在每个episode之后都会重置。在新的episode中，（蓝色所示）因为老鼠有记忆，他知道奶酪不在右下角，所以它会选择不同的动作，这次老鼠向上移动，然后新的记录被加入了历史记录里面，在那个位置时，老鼠也许回采取向右走，但是不是因为他知道奶酪在那里，这里的策略是一种可能性的探索策略，走到右边之后，他获得了奖励。然后因为过了两个时间步，老鼠又重置回到了初始状态，但因为rnn的隐藏状态一直存在，（如黄色所示）所以老鼠会直接采取向上的动作，紧接着采取向右的动作。



Why recurrent policies learn to explore

当我们在整个meta-episode上优化RNN策略的回报时，模型自动学会了探索的策略。这是因为，RNN策略需要在初期探索环境来找到最佳的行动方案，而这个过程无需额外显式编码探索行为，而是通过优化目标自然学到的。



首先，我想先来点背景知识，这不是强化学习（RL）特有的内容。假设我们暂时不考虑之前关于元学习的讨论，回到有监督的计算机视觉任务。在计算机视觉和自然语言处理这些领域，一种常见的方法是拿一个大数据集，比如ImageNet或者大型文本语料库之类的，去训练一个有很多参数的大模型。然后我们可以从这个模型中提取特征，用它的前几层作为特征提取器，然后在这些特征之上加一个新的小型神经网络，对它进行微调，用来解决你可能没有太多数据的下游任务。

举个例子，如果你想训练一个鸟类细分类器，你可以先用ImageNet训练一个大的卷积网络，然后砍掉最后的全连接层，把卷积层拿来作为特征提取器。接着，你可以在这个基础上微调一个新的网络，用来处理你自己小规模的鸟类数据集。

这个过程叫做预训练和微调。其实它解决的问题跟元学习非常相似，因为我们在利用先前任务的数据来帮助自己更高效地学习新任务，尽管在这里只有一个先前任务。

那么，预训练算不算元学习的一种呢？其实还不完全是，因为在预训练中，我们并没有特别去优化模型让它更适合微调。事实上，预训练的效果往往依赖于数据集的选择，比如用ImageNet来预训练就很适合鸟类任务，但用MNIST数字数据集来预训练就不行，因为数字跟鸟类没什么相似之处。

那么，如果我们可以把预训练变成一种元学习呢？如果我们能通过某种方式来预训练，使得网络经过优化后能够更高效地微调到新任务上会怎么样？这其实会让我们获得更好的特征，从而更快地学习新任务。



Meta-RL as an optimization problem P17

这是我们的通用的meta-rl问题，我们必须从经验中改进策略并进行探索。那么如果f theta Mi本身就是一个RL算法，我们可以说这是一个策略梯度算法。在标准RL中，我们会发现，theta star 是相对于预期奖励的theta的argmax，我们这个目标称为j theta，然后我们可以说标准的rl算法将重复的计算新的参数向量theta k+1，这个向量由theta k给出，加上学习率alpha乘以j theta k的theta k梯度，这就是基本的策略梯度。回到左边这个问题上，我们将f theta本身设为RL算法，就可以写成这种形式，现在用它来计算theta梯度和Ji theta，需要与Mi进行交互才能估计梯度，又因为mi的f theta是mi的函数并允许去交互。这就是模型不可知meta learning背后的思想，将mi的f theta定义为关于mdp mi的目标Ji theta上一个或多个梯度步骤。



MAML for RL in pictures



这可能通过图片更容易理解。假设我们有一个策略参数 θ\thetaθ，这是我们的元学习参数。我们正在进行常规的强化学习任务，我们会生成一系列episode，比如在这个例子中，我们正在让机器人学习向右跑，我们将使用这些episode来计算梯度，进行更新，来得到更好的参数theta 撇。但是现在我们在不同的batch当中有多个不同的任务，我们计算梯度的方式是将theta 设置为theta加上meta learning学习率beta乘以多个任务的梯度总和，这个梯度是相对于该任务回报的theta。我们通过在每个任务上执行一次梯度更新得到一个参数向量，因此meta learning的目标是在theta加alpha乘以grad theta ji theta处进行评估。这样做的目的是让模型学到的theta能通过一次策略梯度更新使该任务的表现达到最佳效果。因此，meta 策略梯度实际上包含一个二阶导数。

当然，如果愿意的话，可以在多个梯度步骤中进行更新。

可以将其直观地理解为：如果标记为 θ的粗线表示元优化路径，你会尝试将参数 θ放在这样一个位置，使得每个任务的一个梯度更新步骤（用 ∇L 箭头表示）尽可能接近各自的最优参数，用 θ1∗ ​、θ2∗​ 和 θ3∗ 表示的那些任务的最佳参数。乍一看这有些奇怪，但实际上非常有意义，因为这样一来，除了已有的策略参数外，不需要额外的参数。没有额外的神经网络，只是在训练你的策略参数，使它们能够尽可能高效地适应新任务。



What did we just do??

不过，如果我们回到meta学习的基本概念，监督学习的流程是将 f(x) 应用于 x，得到 y。在监督meta学习中，我们则将 f 应用到训练数据集 Dtr 和输入 x 上，以得到 y。模型不可知的meta学习与此类似，只不过我们使用的是函数 fMAML，将其应用于训练集 Dtr 和 x，或在强化学习的情境下应用于环境 M 和状态 S。

这个函数 fMAML ​有一个特别的形式：在监督学习中，它通过对损失函数进行梯度下降来更新参数θ′，即 fMAML(Dtr,x)=fθ′(x)，其中 θ′是通过一步梯度更新得到的。同理，在强化学习中，可以在期望奖励上使用梯度上升步骤来更新。

可以将这个过程视为一个计算图。因此，如果不确定梯度下降的细节，可以简单地将其理解为另一个计算流程，并使用你偏好的自动微分工具实现。虽然在策略梯度更新时需要谨慎，以确保计算的导数正确，但本质上它只是另一种结构。

这种结构的优势在于它可能具有有利的归纳偏置，因为假设你的强化学习算法是原则性明确且整体优化的，它应当能提升你的奖励。例如，RNN在一些极端任务上可能无法很好地泛化，而强化学习算法在最坏的情况下至少不会比从零开始学习差，因为它是在新任务上通过策略梯度进行学习。



Meta-RL as… partially observed RL?



接下来，我们要讨论如何把元强化学习构建成一个“部分观察的马尔可夫决策过程”，简称POMDP。

一开始，这个思路可能听上去有点奇怪，但其实元强化学习确实可以被视作一个部分观察的MDP。通常的MDP包括状态空间、动作空间、转移概率和奖励，而POMDP在这基础上增加了观察空间 O 和初始分布 E，用于描述在给定状态下观察到某些值的概率。

这里有一个部分观察MDP的图示。我的观点是，元强化学习其实跟常规的强化学习类似，但在POMDP的框架下进行。假设你有一组不同的元训练MDP，比如从 M1 到 Mn。我们想构建一个部分观察的MDP，使得在这个MDP中最大化奖励的过程，就像是在适应一个新的完全观察的MDP一样。

那要怎么实现呢？简单来说，我们需要构建一个部分观察的MDP，主要选择的部分包括状态、观察、发射概率和动态转移。动作空间我们其实不用改变，因为动作空间是一致的。核心问题在于，怎么把一个元强化学习问题嵌入到POMDP里去。

在POMDP中，策略是基于观察 o 来行动的，这通常需要显式的状态估计。也就是说，我们可能会有一个独立的状态估计器，根据过去的观察序列估计 st的概率 p(st∣o1:t)。或者，我们可以使用带有记忆的策略。之前我们在讨论RNN时也提到过带记忆的策略，这里就很有用。

在元强化学习的情境下，我们可以用这种方式来理解这个构建思路。



在Meta-RL中，我们的策略可以表示为 πθ(a∣s,z)，其中 s 是状态，z 封装了完成当前任务所需的信息。之前我们用 ϕ 表示这个变量，但在这里改用 z，后面我们会看到这样做的原因。

如果将学习任务视为推断 z 的过程，那么我们可以通过观察任务的上下文信息（如状态、动作、奖励的序列）来推断出当前任务的 z 值。这样一来，Meta-RL的构建就类似于一个POMDP。



在构建这个POMDP时，我们定义了新的状态空间 S~=S×Z，其中 S 是原始状态空间，Z 表示推断出的任务信息。同时，新的观察空间 O~仅包含原始状态空间中的 S。也就是说，虽然我们无法直接观测到 z，但可以通过观察状态 s 和奖励来推断它。

解决POMDP问题实际上等价于元学习，因为要完成当前任务，我们需要显式或隐式地找出 z 的值。我们可以通过带有记忆的策略（比如循环神经网络）来自动执行这个元学习过程，从而更有效地适应新任务。

不过，这种方法并不是最佳选择，因为POMDP比传统的MDP复杂得多。要解决POMDP，我们可以进行显式的状态估计，比如通过变分推理来学习近似的后验分布，对 z 进行采样，并根据采样结果进行探索。

这个过程的关键在于后验采样策略。我们可以根据过去的状态、动作和奖励分布来估计 z，并将其作为一种探索策略。尽管这并不是最优解，因为它无法收集足够的信息来进一步优化任务识别过程，但在理论和实践中都证明这种方法是有效的。



Variational inference for meta-RL

好的，接下来是一个真正应用了这个思路的算法。这就是 PERL算法，这个算法使用了变分推理来学习 p^​。

在这个方法里，我们有一个策略 πθ(at∣st,zt)，还有一个推理网络 qϕ(zt∣states, actions, rewards)，通过状态、动作和奖励的历史来推断 zt。

训练策略参数 θ 和推理网络参数 ϕ 的目标是最大化策略 πθ​ 在使用 qϕ ​ 获得的 z 时的期望奖励，同时最小化 q(z) 和先验 p(z)) 之间的 KL 散度。这个目标基于变分下界，确保推理的稳定性。

这个方法和我们之前讲的控制推理非常类似，更新后的奖励和标准的元强化学习相同，同时保持接近先验分布，确保 q 能捕捉到分布中的不确定性。在概念上，这个方法和 RNN 的元强化学习非常相似，但这里的 z 是随机的，通过后验采样来实现探索。



在实例化这种算法时，我们需要选择一个合适的架构来构建 qϕ(zt)，这个架构需要基于历史信息。就像 RNN 的元学习过程一样，有很多不同的架构选择，理论上都可以有效工作。

在这篇论文中使用的特定架构，是通过编码器对每个状态转换 (s, a, s', r) 进行编码，然后以一种不受排列顺序影响的方式将这些特征平均，从而得到一个最终的分布。这里有一个有趣的点，那就是在上下文的历史中，我们其实不需要关注转换的顺序，因为在每个 MDP 内部，马尔可夫属性成立，这意味着顺序并不重要。

这种并行编码器架构相比于 RNN 有其独特优势，因为你不需要进行长时间的反向传播。每个转换仅与最终结果相隔一步，因此反向传播路径会短很多。这虽然主要是架构的一个细节，但确实在实践中有帮助。

然后，当然你需要选择一个 RL 算法来执行最大化过程。PEARL 使用的是软行动者评论家（SAC），但你也可以选择其他算法，比如策略梯度方法。

最后，这是论文中的一些实验结果。可以看到，这种方法表现得非常好，当然其中涉及了很多实现细节，影响了这种性能表现。



The three perspectives on meta-RL

在结束本节之前，回顾一下我们之前讨论过的元强化学习的三个视角，或者说至少是无模型元强化学习的三个视角。这三个视角可以通过一个通用的图示来概括：我们要思考 fθ(Mi) 实际上应该做什么。它需要通过经验来改进策略，还要学会如何探索。我们看到的视角包括：

视角一：使用标准强化学习算法训练一个大型 RNN，其中每个元情节都会跨越多个独立的情节。

视角二：双层优化视角，这种视角帮助我们引入了 MAML（模型无关的元学习）算法。

视角三：将其视为一个推断问题，把问题建模为一个 POMDP（部分观测马尔可夫决策过程），并学习如何推断 zzz，即完成任务所需的上下文信息。



RNN 视角在概念上非常简单，也比较容易应用，但它有一些缺点，比如容易导致元过拟合。RNN 是一种非常强大的模型，但如果元训练数据集规模不够大或者不够多样化——这种情况在强化学习中非常常见——模型就可能会发生元过拟合。这意味着它在回忆元训练任务时表现良好，但在处理新任务时泛化能力可能不足。

双层优化视角则有一些优势。它具有很好的外推性，这种一致性意味着即使新任务与元训练任务有所不同，模型通过RL或策略梯度，最终也能学会新任务。尽管加速效果不如分布内任务显著，但这是一个在概念上很优雅的框架，利用了很多优化的理论基础，使我们更好地理解这些方法的有效性。不过，由于涉及二阶导数，这种方法实现起来比较复杂，并且可能需要大量样本来训练。

推理问题视角则相对简单且有效。通过后验采样，它在探索方面表现良好，这种将问题简化为解决特殊POMDP的方式，为设计新算法提供了有力工具。但它也像RNN方法一样，容易出现元过拟合。同时，由于方差和噪声的增加，使得优化和实际应用具有挑战性。



话虽如此，这三种视角在很多方面其实没有那么不同。视角三基本上就是视角一，只是引入了随机隐藏变量。如果我们不考虑POMDP连接的复杂性，你可以把视角三看作是把原来的变量ϕ重命名为z，并加了一些噪声。

视角二在某些方面只是对视角一或三的一种特定架构选择。你可以使用RNN，也可以使用并行编码器，或者添加一个梯度步骤。在某些情况下，这只是不同架构的选择。



Model-Based Meta-RL



Meta learning的最后一部分，我们来讨论基于模型的元强化学习。到目前为止，我们讨论的都是无模型的方法，而基于模型的设置在很多方面其实更简单，因为许多用于监督元学习的思路也可以应用于元模型的训练。在基于模型的元强化学习中，和标准的基于模型设置非常相似，我们会从主要关注策略训练转向更多关注模型训练。通过积累一些经验来改进模型，从而间接提升策略。

基于模型的强化学习的基本步骤是：先收集一些数据，然后用这些数据来得到状态转移模型的近似，接着使用这个模型进行规划。这些方法同样适用于学习策略的基于模型的强化学习算法，但目前我们关注的只是基于模型进行规划的强化学习。使用基于模型的方法的一个重要原因是它比无模型方法需要的数据要少得多，尤其是在元训练阶段。无模型的元强化学习算法可能在适应上效率很高，但在元训练阶段依旧需要大量资源，而使用模型可以缓解这一问题。

此外，基于模型的元强化学习算法在理论上可以适应得更快。因为无模型的方法最终是通过观察奖励来调整，而基于模型的元强化学习则可以仅通过观察模型预测误差来进行调整。这意味着即便还没得到实际的奖励反馈，模型已经可以根据对下一个状态预测的准确性来进行自我修正和适应。



我们讨论一个基于模型的元强化学习示例，展示了任务或情境可能在单个情节中发生变化的情况。假设你有一个蚂蚁机器人，在某个时刻它的一条腿断了。原本适用于四条腿的行走方式现在行不通了，因为它只有三条功能完好的腿。如果能快速调整模型，它仍然可以继续行走。

非自适应方法的步骤是：收集一些数据片段，然后训练一个模型来预测状态转移，之后利用这个模型优化动作选择，比如通过规划完成。

而自适应方法则是每执行一步，就观察当前状态、动作和下一个状态，并据此更新模型。可以使用与模型无关的元学习方法或RNN等方法，然后利用更新后的模型来优化接下来的动作。实际上，如果愿意的话，甚至可以在每一个时间步都调整模型。

但是，如果没有元训练，仅仅天真地采取这些梯度更新，可能无法在一步中完成有效适应。所以没有元训练的自适应方法并不适用于深度网络。它可以在简单的模型上有效，比如线性模型，这也是自适应控制领域关注的问题。但对于深度神经网络模型，仅凭一个样本很难做出大幅调整。然而，通过元学习，我们在元测试时可以实现更有效的适应性调整。



在元测试时，我们会采用这种自适应过程，但在训练时，我们会构建一个元训练集，就像在监督学习中那样。就像我们在讲座开头看到的Ravi和Lara Shell的图示一样，元训练集包含多个训练集和测试集。

接下来要解决的问题是，我们如何构建这个元训练集。一旦构建好它，我们就可以使用任何有监督的元学习算法来进行训练，包括模型无关的元学习方法、RNN方法或其他任何方法，然后在测试时用于适应。因此，真正需要弄清楚的是如何在训练时构建它们。元训练集由一组训练-测试子集组成，我们在训练时通过在D_train上进行适应，来调整我们的适应过程，以便适应后的模型在D_test上表现良好。

这里，x表示(s, a)，y表示s'，所以我们可以生成每个D_train和D_test。具体操作是从过去的经验中随机抽取一些子序列，从s_t到s_t+k。假设我们过去的经验包含了许多不同的动态，比如可能之前我们见过腿断了的情况，或在不同地形上移动的情况。我们并不需要知道任务的边界，只是随机抽取这些子序列，然后定义D_train为从s_t到s_t+k-1的部分，而D_test是最后一个时间步的转换，即(s_t+k, a_t+k, s_t+k+1)。

我们可以选择k=1，但k大于1效果更好，比如k=5。这样，我们就能在从D_train适应后，在D_test上得到较好的结果。如果有一条长的轨迹，我们可以选择其中的一段作为D_train，后续的部分作为D_test。这样做的好处是，这种构建方式和元测试时的情况非常相似：在元测试时，我们会获得一个或多个步骤的数据，然后需要在后续步骤中表现良好。

通过这种训练方式，我们在元测试时能获得较好的效果。比如在这里断腿的任务中，使用经过元训练的模型后，一旦检测到腿断了，模型能够迅速适应，帮助完成任务。







lec23



主要讨论深度强化学习领域中的一些挑战和未解决的问题，同时分享一些关于如何使用深度强化学习方法，以及在该领域进行研究的实用建议。

首先，让我们来看一下深度强化学习中的一些关键挑战，主要包括核心算法和基本假设两方面的问题：

稳定性：你的算法是否能够收敛？是否可以对算法的行为做出任何保证？

效率：算法收敛需要多长时间？需要多少样本？计算资源的需求有多大？

泛化能力：算法收敛后，得到的策略模型或价值函数能否有效地泛化，适应新的场景？

除此之外，强化学习的基本假设也带来了挑战。如果我们希望将强化学习应用于现实世界场景，就需要重新审视这些假设。例如，强化学习的基本问题设定是否适合基于学习的控制任务？在强化学习中，监督的来源应该是什么？这些问题都需要进一步思考和研究。



首先，让我们谈谈在深度强化学习中的一些核心挑战，包括算法的稳定性和超参数调节。你的算法是否能够成功收敛？设计稳定的强化学习算法是非常困难的，每类算法都有自己特有的问题。

以 Q 学习和价值函数估计为例。使用深度神经网络逼近的拟合 Q 值方法通常无法保证收敛，导致我们必须费力调整超参数以获得好的效果。例如，我们需要调整目标网络延迟、回放缓冲区大小、梯度裁剪、学习率等，这样才能让算法学习出有效的 Q 函数和价值函数。

此外，政策梯度或 REINFORCE 方法也面临挑战。尽管理论上它们是无偏的梯度估计，但在实践中存在高方差的问题，导致需要大量样本和精细的学习率调整，才能确保稳定的性能。我们还需要优化批量大小、学习率、基准设计等超参数。

在基于模型的强化学习算法中，还有一系列更复杂的设计决策，例如选择合适的模型类别、拟合方法、模型架构等。这些决策会显著影响算法的稳定性和性能。同时，优化模型下的策略并不容易，例如反向传播时间问题或生成合成轨迹时会继承无模型算法的缺点。此外，策略在模型下可能倾向于“利用”模型缺陷，从而生成不现实的行为，这也为实际应用带来了挑战。





如果你想在现实世界中应用强化学习，显然无法像在实验中那样进行超参数扫描，因为不可能让真实系统运行几十次来验证哪种参数效果最好。不过，你可以考虑使用模拟器来调整参数。至于模拟器的代表性，通常并不是很高，但可能足够接近实际情况，让你能先在模拟器上调整超参数，然后再将优化后的参数应用到真实系统中。

如果你依赖于超参数扫面并且所有工作都在模拟环境中进行，那么你需要注意，算法的实际样本复杂度等于算法运行时间乘以扫描中的运行次数。可以把它看作是一种元强化学习算法，结合了随机搜索或超参数优化和基于梯度的优化。实际上，一些研究人员已经提出了这一过程作为一种算法，通常在超参数优化上使用无导数优化，灵感源自进化算法和遗传算法。

另外，我们还可以探索开发对超参数不那么敏感的、更稳定的算法，这是当前一个活跃的研究领域。如果你希望在深度强化学习领域产生影响，开发对超参数不敏感的算法无疑是一个非常重要且有价值的方向。



那么，我们能做些什么？我们可以尝试设计具有良好改进和收敛特性的算法。例如，一些研究表明，在某些限制性假设下，算法可以提供改进的保证。在讨论策略梯度时，我提到了基于“信任区域策略优化”（Trust Region Policy Optimization）的保证。此外，还有关于“安全强化学习”和“高置信度策略改进”的研究。如果你对此感兴趣，可以参考Philip Thomas的一些工作。

另外，还有一些算法可以自适应地调整参数类型，例如Gu等人在Q-Prop论文中提出的方法，通过控制变量或基线与回报的相关性，自适应调整其强度。

不过，这方面还需要更多的研究。通常，在深度强化学习研究中（尤其是在学术领域），研究人员更关注渐近性能的改进，而不是算法的简单性和超参数的敏感性。因为性能改进可以被测量并展示在图表中，而提高超参数的鲁棒性和降低敏感性则相对较难展示，因为这涉及到与已经调优的其他方法的对比。

希望正在考虑研究深度强化学习的你，不会被这些挑战所吓退。减少超参数数量、自动化调参过程以及降低对超参数的敏感性，是使深度强化学习真正实用的重要方向。虽然这些改进对击败基准性能并没有直接帮助，但对于使强化学习成为解决现实世界问题的可行工具却至关重要。



为了使强化学习在现实问题中成为一种可行的工具，简化和稳定算法是必不可少的。接下来我们来探讨样本复杂性。

在这个幻灯片中，我将展示不同方法的样本复杂性对比，逐步从最耗费样本的方法讲到最节省样本的方法。首先，我们来看那些需要最多样本的无梯度方法。这类算法用于强化学习目标时完全不需要反向传播。接下来是完全在线的算法，例如A3C，这类方法在策略上进行一步并立即更新。然后是批处理模式的策略梯度方法，如TRPO和PPO，它们会采样多个轨迹后再进行更新。之后是基于重播缓冲的离策略算法，例如Q学习、DDPG、NAF和SAC，这类方法利用离线的策略数据进行学习。

再往下是基于模型的深度强化学习算法，如PETS和引导策略搜索。这些方法能够更快地学习。而在底部，我们有基于模型的浅层方法，如PILCO，这些方法不使用神经网络，而是采用高斯过程等更高效的函数逼近器。

举个例子，像进化策略这样的无梯度方法通常需要多10倍的样本才能达到与下一层方法相似的效果。A3C方法在“半猎豹”任务中需要约1亿步，换算下来相当于连续运行15天左右。TRPO在稍微复杂的“半猎豹”任务上需要约1000万步，大约1.5天的实时训练时间。而对于DDPG等离策略方法，这个任务的时间需求缩短至约3小时。基于模型的深度强化学习方法则进一步缩短了时间，例如PETS可能只需要几分钟。基于模型的浅层方法甚至可以在几秒内学到任务，但这种方法的计算成本非常高，且在复杂任务上容易受到维度限制。

需要注意的是，不同方法在样本效率上存在10倍的差异，这只是一个粗略的估计，适用于那些所有方法都能表现良好的任务。对于样本获取非常便宜或者可以并行计算的任务，例如棋类游戏或简单物理模拟时，样本效率较低的方法可能更具优势，因为它们并行计算能力强，能更快得出结果。

对于一些基于离策略值的方法，虽然样本复杂性较低，但计算成本较高。例如，DDPG和SAC在训练时，生成样本和执行计算的时间接近甚至超过了样本收集时间。对于极端情况下的浅层方法，如PILCO，样本所需时间虽然很短，但计算时间却可能长得多。因此，虽然它们在样本数量上效率高，但计算时间却可能超过一个小时。

综上所述，虽然在实际应用中选择方法时我们会考虑样本效率，但计算成本也是不容忽视的因素。在某些情况下，即便样本效率较低的方法，也能通过并行计算获得较快的结果。因此，选择适合的方法时，应权衡样本复杂性和计算成本，以确保在现实场景中更好地满足需求。



样本复杂性带来的挑战主要体现在以下几个方面：

首先，高样本复杂性会导致训练过程耗时过长。在实验环境中，这意味着作业完成需要等待很长时间，而在真实场景中，这种延迟会让强化学习的应用变得困难，甚至不切实际。例如，如果要训练一个控制化工厂或机器人的策略，需要连续数天的运算时间，这在实际操作中可能完全无法实现，因为训练过程需要配套的安全机制和人工监督。

其次，高样本复杂性限制了高成本、高精度模拟器的使用。虽然我们可以利用高端有限元方法等模拟器来模拟复杂现象，但这些模拟器的运行速度通常比实时还要慢，导致强化学习无法在其上有效执行。这种情况在高端模拟器中非常普遍，极大地限制了强化学习在实际问题中的应用。

因此，如何有效解决样本复杂性问题是一个重要的课题。如果我们能在保持算法有效性的同时减少样本需求，将大大提升强化学习在真实世界中应用的可行性。



我们可以采取哪些措施来应对样本复杂性的问题呢？

改进基于模型的强化学习算法：通过开发更好的模型来提高样本利用效率，加快学习速度，从而在实际应用中减少对大量样本的依赖。

设计更快的算法：例如，在离策略强化学习领域，已有许多方法尝试通过不同的技巧来加速算法，如DDPG风格的算法。此外，Soft Actor-Critic（SAC）是一种高效的最大熵强化学习算法，也是离策略方法之一。在该领域还有许多其他研究都致力于加速算法的执行效率。

重用先验知识：可以通过多种方式利用已有的知识来加速强化学习过程。例如，使用元学习（Meta-Learning）技术，通过在不同任务中的学习经验来快速适应新任务；也可以使用离线强化学习（Offline Reinforcement Learning）算法，借助已有的数据或相关任务的知识，从而减少所需样本量，加速强化学习过程。

这些方法有助于缓解样本复杂性带来的挑战，从而让强化学习更高效、更易于在现实世界中应用。



在这一部分中，我们来探讨深度强化学习（Deep RL）的扩展性和泛化能力。深度强化学习从一开始就备受关注，部分原因在于它的潜力：结合强化学习算法的优势（学习接近最优的行为和控制策略），以及深度学习的强大泛化能力。例如，当我们在类似ImageNet这样的大型数据集上训练一个高容量的卷积神经网络时，模型对新图像的泛化效果会非常好。

然而，许多使用大数据集的监督学习任务通常是大规模任务，强调多样性和泛化能力的评估。相对而言，强化学习的研究大多集中在小规模任务上，更注重掌握程度，通常以最终奖励来衡量算法的表现。这意味着强化学习算法的评价标准往往并不是其泛化能力，而是它在训练过程中获得的最终奖励。

举个稍显夸张的例子，这种做法就好比我们用一张图像的分类信心度来评估图像分类器，认为置信度高的分类器更好，然而在图像分类任务中，真正重要的是分类器能否对未见过的新图像给出正确答案，而不是对训练数据中的图像置信度高低。对于强化学习来说，这种测试方式显然并不理想，因为我们常常是在“训练集”上进行测试，而非真正的泛化测试。

因此，如果我们真正追求泛化，那么仅仅关注表现可能不是最佳选择。一个疑问是，强化学习的泛化能力究竟如何体现？我们又该如何提升这种能力？ 实际上，在泛化问题上，强化学习面临着巨大挑战。



问题可以这样理解。在监督学习中，我们的工作流程相对简单：首先从现实世界收集数据，但这一步通常只需要进行一次。数据收集完成后，我们将其保存到磁盘中，可以反复使用这些数据。然后，通过这些数据，我们可以多轮次地训练模型，同时使用验证集来评估模型的表现。一旦对模型的效果满意，就可以将其部署到现实世界中使用。

而在强化学习中，流程则复杂得多。我们有一个智能体（agent），需要不断地与环境交互，收集数据、改进策略。每次改进之后，智能体都必须再次进行交互，重复这一过程，不断更新策略，才能逐步学习出一个最优的解决方案。这种频繁的数据采集和策略更新，使得强化学习在实际应用中面临更大的挑战。



在强化学习中，智能体需要多次重复交互，收集数据并不断改进策略。这种过程的循环，使得使用大数据集变得相当困难。因为如果希望智能体更新其模型，往往需要为每次实验重新收集数据。即使使用非策略算法，通常每次实验也需要额外的数据。

但实际上，强化学习的情况比这理想化的图景更加复杂，因为在实际的强化学习中，还存在一个外层循环。这个外层循环的主体是算法设计者，比如研究生、本科生或研究人员。他们需要不断修改算法、调整超参数，进行变更和优化，以使算法效果更好。这一外层循环围绕着整个迭代过程，使得即便强化学习在理论上可以多次迭代和收集大数据集，在实际中因调试和调整算法的工作量巨大，这一过程变得完全不切实际。



作为替代方案，我们不仅仅需要关注离策略的强化学习（off-policy RL），而是需要深入研究类似于离线强化学习（offline RL）的方法。正如在他的演讲中所讨论的那样，我们可以记录来自过去交互的大型数据集，只在偶尔情况下收集一些新的数据。这样实际上进入了离线强化学习算法的领域，尤其当我们希望在不重新收集新数据的前提下进行算法的调优和设计时，离线 RL 显得尤为重要。这也是为什么离策略 RL 和更极端的离线 RL 变得如此重要的原因，当然这不仅仅适用于强化学习的某些特定领域。



不只是机器人领域。在很多领域中，这些问题更加严峻。比如在自动驾驶领域，尽管可以轻松从人类驾驶员的数据中获取大量的历史交互数据，但要让自动驾驶汽车在美国各个城市中轮流测试并在每次策略更新后进行重新训练，几乎是不现实的。

语言和对话系统也是类似的情况，虽然可以获得丰富的历史语言数据，但要获取大量实时的在线交互数据却非常困难。

在其他领域，如运营研究、金融、物流、库存管理等，实现有效的泛化能力通常需要大量的数据支持。这些数据虽然确实存在，但要在部分训练的强化学习策略下主动在线收集这些数据，却非常具有挑战性。



到目前为止，我讨论了一些与核心算法和强化学习相关的挑战。关键在于，如果我们保持强化学习的原有问题定义，那么我们会面临哪些挑战？以及我们如何开始思考解决这些问题。在讲座的下一部分，我将讨论一组更基础的挑战，这些挑战与强化学习方法中所做的假设有关，无论这些方法的效果如何。首先，让我们来谈谈问题的本质。



首先，我们来谈谈问题的描述。我们在设定强化学习问题时，需要解决一些核心问题。其中一个问题是：我们想要解决的是单任务问题，还是多任务问题？正如我之前提到的，现实世界并非那么简单，它具有高度的多样性和变化性，而这种复杂性正是我们希望实现泛化能力的来源。

实际上，RL问题的传统描述基本上是围绕单任务进行的。虽然我们可以通过构建一个融合的马尔可夫决策过程（MDP）将多个MDP合并为一个，从而扩展到多任务场景，但多任务学习对我们期望的泛化效果来说至关重要。因此，我们或许应该更明确地将多任务学习纳入强化学习的框架中，比如在测试阶段，系统会遇到训练时从未见过的新MDP。

在这种情况下，RL的基本问题描述可能显得有些局限。通常情况下，我们认为每个回合会从一个随机选择的初始状态开始，测试阶段也会给出一个随机初始状态。然而，这种方式可能不够理想，因为它意味着只要训练时间足够长，就能遇到所有的情况。但实际上，我们可能更希望有一个“训练集”和一个“测试集”，或者找到一种其他方法，将对未见过情况的泛化作为首要目标。

因此，也许不需要重新定义问题，但这个差异确实值得进一步关注。如果你正在考虑重新思考强化学习问题的描述，不妨思考单任务和多任务学习的差异，以及它们对泛化效果的影响。



在多任务学习的泛化方面，可以考虑以下几种方法：

首先，可以通过对多个任务进行训练，再进行微调来实现泛化。这类似于我们在迁移学习课程中讨论的方法。我们在课程中也提到了一些相关的引用和研究。

另一种方法是对多样化行为进行无监督或弱监督学习。例如，在预训练阶段可以接触到各种各样的情况，之后在微调阶段可以利用在无监督阶段学到的知识，在更狭窄的环境中学习新任务，并能够推广到更多种类的情境中。这种方法类似于监督学习领域中的无监督预训练。

此外，还有一些研究论文探讨了这一方法的变体。在信息理论探索课程中，我们也详细讨论了这一点。这可能是重新思考问题设定的一种方式，有助于更好地解决泛化问题。

这仍然是一个开放的研究领域，目前没有明确的答案，但可以作为一个潜在的探索方向。



下一个问题是，在强化学习中监督来自哪里？

在监督学习中，监督的来源非常清楚，系统会告诉你给定输入的正确标签或正确输出。而在强化学习中，监督的来源是什么呢？

简而言之，监督来自奖励函数，但同时也受到我们在设置马尔可夫决策过程（MDP）时所做的许多其他设计决策的影响。如果你希望系统能够学习许多不同的任务，你需要从某处获取这些任务，可能在选择行动层面上不需要精细的监督，但对每个任务的奖励级别需要有一定的监督。

在某些环境中，监督来源相对简单，比如视频游戏中可以很直观地设定奖励，但在其他环境中则复杂得多。例如，如果想通过强化学习让机器人学会倒水，光是判断杯子是否装满水就是个难题。如果我们想用强化学习来训练一个充当治疗师的聊天机器人，虽然看起来像是一个可以解决的机器学习任务，但如何定义“有效的治疗”本身几乎和生成对话文本一样困难。

也许我们可以通过逆强化学习的演示来学习目标或奖励，以解决这一问题，或者我们可以像在无监督学习讨论中那样自动生成目标。但如果我们退一步，用更基础的方式思考奖励函数在强化学习中的作用，我们可能希望奖励函数的作用是告诉智能体该做什么。



奖励函数的作用是告诉智能体“做什么”，但在实际应用中，奖励函数往往不仅需要指定目标，还需要指引“怎么做”。就像我们在课程中提到的那样，奖励函数有时需要更加细致地设计，才能帮助智能体学习完成任务的过程。

比如，在一个行走任务中，我们可能会设想一个简单的奖励规则：智能体成功行走就得到奖励，否则没有。然而，实际情况中，我们往往需要更复杂的奖励设计，比如根据智能体的速度、躯干是否保持直立等多种因素给予不同的奖励。你们在作业中遇到的奖励机制也是类似的，设计得相当精细。

有人可能会认为这是因为当前的强化学习方法还不够完美，导致我们不得不设计复杂的奖励机制，但实际上，人脑中的奖励机制也并非简单。大脑中的基底神经节并不像一些描述那样，只有“吃到美食获得好奖励，否则得到坏奖励”的简单反应。基底神经节中的奖励机制非常复杂。

想象猎豹捕猎瞪羚的情景。如果猎豹只能在成功捕猎后获得奖励，那么它的学习过程会非常困难，因为随机捕到猎物的机会极低。如果在第一次成功捕猎前，猎豹无法感知到这种行为的奖励，那么它很可能永远无法掌握这一技能。因此，一个复杂的奖励机制是有必要的。

在强化学习中，我们可以将这种复杂性视为算法问题，通过开发更能适应复杂奖励的算法来解决这一挑战。但我们也可以从根本上思考：奖励机制的本质应该是什么？这种反思可能会帮助我们重新设计和优化强化学习的奖励系统。



我们可以重新思考奖励机制的设计。或许可以尝试无监督强化学习，即在没有明确奖励函数的情况下与环境互动，探索可能的行为和可以达成的目标，然后将这种知识应用到新的任务中。通过无奖励的互动，我们可以更好地理解环境，为未来的任务提供基础。

这种无监督探索不仅是一种有效的知识获取方式，也有助于广泛应用到新任务中。当然，这只是解决问题的一个方向。

另外，我们也可以考虑其他可能的监督来源，以更全面地探讨和应对这一挑战。



当我们重新思考强化学习问题的表述时，有许多方面值得我们重新审视。我们可以思考如何定义控制问题，是将其定义为“最大化奖励”，还是采用数据驱动的方式，亦或是定义为“匹配某种观察到的行为”？数据是什么？目标是什么？监督是什么？监督是否等同于目标，还是有其他形式的监督，比如奖励和一些示范？这些都是值得考虑的合理选择。

在定义控制问题时保持开放的心态是很有必要的。重要的是要思考哪种假设最符合问题的背景条件。无模型的标准强化学习表述是否适合当前问题？还是说，有其他方式可能更简单，或者能提供更有效的信息？

此外，不要将强化学习问题的基本表述视为一成不变的。重新思考问题表述，考虑哪种表述可能更易处理、更具扩展性，或者更适用于你所关注的问题情境。





在本课程的第一堂课中，提到可以将学习视为智能的基础，也许我们可以把强化学习看作一种机制，使我们能够推理和决策。深度模型让强化学习算法能够学习并表达复杂的输入与输出映射，深度模型和强化学习结合起来，使得算法可以端到端地解决复杂问题。



为了在现实环境中表现智能，一个系统需要获得足够的信息，无论推理能力多强，如果对世界一无所知，也无法表现出智能。所以，从某种粗略的角度来看，训练智能机器的问题就变成了向计算机填充足够的信息的问题。

过去十年来，数据驱动的方法展现了这一观点的合理性——通过大量数据，系统可以识别各种边缘情况、异常情况等。当世界难以用简洁的规则描述时，就需要大量的信息来理解各种情况。

不同学习方式的信息密度各不相同。在监督学习中，每个标签可能只包含少量的信息，比如在 ImageNet 中，每个标签大约有 10 位的信息。如果有一百万张图像，总共大约有 1000 万位的信息，也就是 10 兆字节。

在强化学习中，监督的信息密度可能更低。特别是在稀疏奖励的情况下，每个样本可能几乎没有信息，因此监督的密度可能非常低。然而，在无监督学习中，比如预测未来图像的任务中，每个样本可以包含数百万位的信息密度。

因此，若要实现真正的智能机器，就需要无监督或预测学习方法，因为它们能够提供更高的信息密度。无监督学习虽然不提供人类的知识标签，但它能让系统观察世界，学习物理规律、因果关系和宇宙结构。

这可能引发一些深思——也许我们可以通过无监督学习的方式，让系统从世界中获取大量观察性知识。



奖励机制和监督信号在强化学习中可能有多种来源。首先，无监督学习的观点认为，模型通过观察性知识从与环境的互动中学习，这种知识涵盖了物理、因果关系、宇宙结构等广泛内容。该观点认为，若要实现智能机器的目标，我们需要通过无监督或自监督学习提供密集的信息，使模型在尚未达到特定目标或获得奖励之前就积累丰富的认知。

另一种观点认为，监督不仅来自于环境的物理属性，还可能源自其他智能体的行为。我们能够驾驶汽车、制造飞机、使用计算机，或许并非全因个体智力的卓越，而是因为我们生活在一个社会环境中，通过模仿和理解他人行为而获得丰富的监督信号，从而在合理的样本复杂度下实现有意义的行为学习。

此外，强化学习的奖励信号可能并不稀缺，相反，它可能提供了大量的信息。当奖励通过系统中的动态状态传播，并与状态转换结合时，会形成一个丰富的监督来源。因此，预测哪个状态具有高价值是一个复杂的问题，而价值函数将动态与奖励结合，提供了深层次的监督信号。该观点认为，只需改进基本强化学习方法，就有可能在有限的监督下实现丰富的学习效果。

综上所述，或许答案在于整合以上各种监督来源。这意味着问题的复杂性可能要求多种监督来源的协同作用：无监督学习与预测、对其他智能体的模仿理解、以及强大的基本强化学习算法，以从有限的奖励中提取丰富的监督信号。



在本次最后，还有一些问题。首先，我们在强化学习中需要选择正确的问题。不要过分依赖基准任务，因为强化学习本质上是一个结合了优化和机器学习的特殊领域。在优化中，我们强调如何更好地解决优化问题，而在机器学习中，我们则更注重泛化能力。当前的许多强化学习基准任务实际上是优化任务，但现实世界中的复杂性和多样性并不一定能够通过这些基准任务来代表。因此，我们应该考虑那些具有代表性的现实世界问题，它们或许并不是机器人技术的典型应用，而是包括对话生成、物流运营、医疗保健、教育等数据驱动的强化学习问题。选择这些正确的问题能够确保我们的算法创新有潜力去解决这些实际存在的复杂问题。

此外，要关注生成模型、预测及其他机器学习领域的进展，而不仅仅局限于强化学习算法。强化学习的下一次重大创新很可能来自于引入其他领域的思想，改变我们对问题的看法，调整我们的假设或问题表述，或带来新的算法思路，这些在几十年的强化学习研究中尚未被充分探索。

我们还需要深刻理解强化学习与其他领域之间的关系。在某些层面上，强化学习其实与分布匹配、处理分布变化等机器学习的其他领域并无太大差异。理解这些相同点和不同点有助于我们将新的思维方式引入强化学习研究。

<html><head><title>Lec22</title></head><body><article><h1>Lec22</h1><p></p><p>What is the meta-learning？</p><p>如果你已经学会了100个不同的任务，是否可以利用这些经验更高效地学习新任务呢？在这里，拥有多个任务的学习经验被视为一个巨大的优势，因为我们可以通过总结这些经验，提高模型适应新任务的速度。</p><p>什么是元学习？简单来说，元学习就是“学习如何学习”。和传统的学习不同，元学习不仅仅关注具体任务的解法，而是希望通过学习过程本身，获取一种可以适用于更多任务的学习方法。这使得模型在面对新任务时，能够更快速地适应，而不必从头开始。</p><p>元学习与多任务学习关系密切。多任务学习是在多个任务之间寻找共同点，而元学习则更进一步，通过总结多个任务的学习经验，帮助模型在新任务中更快找到解决方法。</p><p>我们来看元学习的几种实现形式。元学习可以训练一个优化器，使模型在遇到新任务时更快收敛；也可以使用递归神经网络，通过吸收过去的经验来帮助适应新任务；还可以通过学习一种高效的表示，使模型在微调时更加高效。</p><p>右边的图展示了一个元学习优化器的例子。普通的梯度下降优化器只是简单地沿着梯度方向前进，而学习过的优化器可以通过过去的经验更聪明地调整策略。当它遇到类似的情景时，可以避免走弯路，更快达到收敛。这种“记住之前情况并调整优化路径”的能力，正是元学习的一个优势。</p><p></p><p>Why is meta-learning a good idea?</p><p>首先，我们知道，深度强化学习，特别是无模型的强化学习，通常需要大量的样本。这是因为模型在每个新任务上都需要从头开始探索和学习，积累足够的经验，才能找到最优解。这对时间和计算资源都是很大的消耗。</p><p>那么，如果我们可以通过元学习来加速强化学习的过程会怎么样呢？元学习的一个核心优势在于它可以利用过去的学习经验，帮助模型更高效地适应新任务。通过元学习，我们可以训练出一个更快的强化学习模型，从而显著减少样本需求，更加高效地应对新任务。</p><p>那么，元学习模型与传统强化学习模型相比，到底可以做得更好呢？首先，元学习模型可以更智能地探索环境。通过识别任务中的相似模式，元学习模型可以优化探索策略，避免重复无效的尝试。其次，元学习模型可以避开那些已知无用的操作，这样可以更快地找到有效的解决方案。最后，元学习模型能够更快速地获取任务所需的关键特征，从而更迅速地适应新环境。</p><p>通过元学习，模型不仅可以减少学习新任务所需的样本量，还能提升在新环境中的适应速度，真正实现“学习如何更高效地学习”。这也是元学习在深度强化学习中极具吸引力的原因所在。</p><p></p><p>Meta-learning with supervised learning</p><p>这张图片展示了元学习的两个主要阶段：元训练和元测试。在元训练阶段，我们会让模型在多个不同的任务上进行学习。每个任务都有自己的训练集和测试集，包含了不同的类别，比如上半部分我们可以看到有鸟、蘑菇、狗等等。通过在这些不同任务上的训练，模型积累了丰富的经验，为之后的任务打下基础。</p><p>接下来是元测试阶段。在这一阶段，模型会遇到全新的任务，这些任务中的类别在训练过程中是从未见过的，比如狗、狮子、碗等。元学习的核心目标就是让模型利用在元训练阶段积累的经验，能够快速适应这些新任务，即便每个新类别的样本很少。</p><p>可以看到，每个任务都有独立的训练集和测试集。在元训练过程中，模型在多个任务的训练和测试中不断优化，提取出一种通用的学习策略。在元测试时，模型可以利用这种策略来高效适应新的任务类别。</p><p>总结来说，通过元学习，模型实现了“学习如何学习”的能力。即便在面对从未见过的类别时，只要给少量样本，模型也能快速准确地进行分类。</p><p></p><p>Meta-learning with supervised learning</p><p>在传统的监督学习中，我们学习的是一个从输入到输出的函数，也就是模型输入一个样本，比如一张图片，然后输出对应的标签。而在元学习中，我们希望模型学会一种可以快速适应新任务的学习方法。这就不仅仅是一个简单的输入输出关系了，元学习还会利用整个训练集来帮助预测新样本的标签。</p><p>我们可以使用少样本训练集，比如包含了少量的(x,y)对，然后利用这些样本来预测测试样本的标签。这里我们可以使用递归神经网络（RNN）来读取训练集，因为RNN可以顺序处理样本，将前面样本的信息累积起来，从而更好地预测新的样本。</p><p></p><p>What is being “learned”?</p><p>在传统的监督学习中，我们通常会找到一组最优参数，使得模型在训练集上取得最小的损失。比如，在一般学习中，模型的目标是找到参数 θ∗，使得在训练集上的损失最小化。这种情况下，模型的学习是直接针对单一任务的训练集进行的。</p><p>但是，在元学习中，我们的目标不仅仅是学习一个任务，而是希望模型能够快速适应多个任务。因此，元学习需要找到一组“元参数”，这些元参数可以帮助模型快速适应新任务。我们可以看到，在一般元学习中，我们的目标是找到元参数 θ∗，使得它在多个任务的平均损失最小化。通过这些元参数生成的学习算法，可以根据每个任务的训练集生成特定的任务参数 ϕi​，从而在不同任务的测试集上表现良好。</p><p>这就是元学习的独特之处：它不是直接学习任务的解决方案，而是学习如何去快速适应新任务。这种“学习如何学习”的能力，使得模型可以在少样本的情况下迅速适应新的任务，真正实现了少样本学习的效果。</p><p></p><p>What is being “learned”?</p><p>首先，在左侧我们看到的是少样本训练集，其中包含了几个样本对 (x1,y1),(x2,y2),(x3,y3)。模型依次接收这些样本，逐步生成并更新隐藏状态，累积来自这些样本的信息。</p><p>随着每个样本输入，模型逐渐构建出一个关于当前任务的表示，最终生成一个完整的任务隐藏状态 hi。这个隐藏状态结合元学习得到的权重 θp ​，形成任务特定的参数 ϕi。</p><p>最后，右侧展示了如何利用这些任务特定的参数来对测试样本 xtest​ 进行预测。通过这种方法，模型能够在仅有少量样本的情况下实现对新任务的快速适应和有效推断。</p><p>在这张幻灯片的右下方，我们看到元学习的参数结构。任务特定的参数ϕi包含两个部分：RNN生成的隐藏状态 hi和元学习过程中获得的权重 θp。当模型遇到新的任务时，通过少量样本生成隐藏状态 hi​，然后结合元参数 θp​，模型能够迅速适应新任务。</p><p></p><p></p><p>The meta reinforcement learning problem</p><p></p><p></p><p></p><p>我们假设有若干个用于元训练的 MDP（马尔可夫决策过程），例如 M1​ 到 Mn ​。这些 MDP 可能在动态特性或奖励机制上有所不同，但通常我们假设它们都来自同一个分布 p(M)。这个假设与监督学习中的独立同分布假设类似。在监督学习中，我们假设训练数据 x 和 y 来自某一分布；在这里，我们假设元训练 MDP 也来源于同一个分布。</p><p>在元测试时，我们同样假设新的测试 MDP 来自这个分布。然后，我们可以在这个测试 MDP 上运行适应过程 fθ​ 来获得相应的适应参数 ϕ。这种假设意味着元训练和元测试任务来自同一个分布，但并不要求它们是相同的任务，只是它们从同一个来源抽样。</p><p>举个例子，可以有多种机器人任务，如端茶、搬运家具、折叠衣物等，这些任务可以作为元训练 MDP。在测试时，我们可能会遇到一个新任务，比如清洁地板。我们假设所有这些任务来自相同的任务分布，并且测试任务也属于这个分布。在实际操作中，这个假设更像是一个技术性假设，就像监督学习中的独立同分布假设一样，通常很难精确验证它。</p><p>另一个更简单的例子是半猎豹机器人。在元训练阶段，任务可能是让机器人以不同的速度和方向奔跑，而在元测试时，任务可能要求它适应新的速度或方向。这些例子展示了两种情况：一种是让机器人学习多种任务，另一种是让它快速适应新的速度和方向。</p><p></p><p></p><p>Contextual policies and meta-learning</p><p>在迁移学习的讲座中，我提到过“上下文策略”的概念。上下文策略是一种接受额外参数的策略，这个参数之前被我称为ω，它向策略传达了具体的任务指令。</p><p>可以将元学习视为与上下文策略紧密相关的一种方法。在元学习中，上下文并不是直接提供的，而是通过策略在完成特定任务时积累的经验推断出来的。我们可以从两个角度来理解元学习：一是将其视为一种双层优化结构，其中 ϕ 等于 fθ(Mi)；二是将其理解为基于任务历史的策略，这个历史包含了任务中的所有状态、动作和奖励信息。这样的结构与上下文策略类似，但不同之处在于，这里没有直接提供描述任务的变量，而是通过观察历史数据（如奖励）来推断任务。</p><p>在元学习中，上下文的作用是帮助推断出完成任务所需的全部信息，通常包括策略在 MDP Mi 中观察到的状态、动作和奖励。因此，我们可以将其等价地表示为上下文策略 πθ(at∣st,ϕi)，其中 ϕi 是通过 fθ(Mi) 生成的上下文。</p><p>在元强化学习（meta-RL）中，上下文是从新的 MDP Mi 的经验中推断出来的；而在传统的上下文策略中，上下文通常是由用户直接提供的。例如，在前面的讲座中，我们讨论了不同的上下文概念，例如乐高积木的堆叠位置、行走的方向、击打冰球的位置等。在元学习环境中，模型需要通过观察任务的状态和奖励信息来推断出这些上下文，而不是直接给出这些信息。</p><p></p><p>Meta-RL with Recurrent Policies</p><p>首先，我们讨论元强化学习算法的一个简单类别：使用循环策略的元 RL 算法。与我们之前在监督学习部分讨论的模型类似，这些算法通过历史数据进行学习和适应。</p><p>在实现元强化学习算法时，关键问题是如何实现函数 fθ(Mi) 以及这个函数需要做什么。其主要目标是利用从环境 Mi中收集的经验改进策略。通过选择动作并从环境中获得反馈，算法需要使用状态、动作和奖励的历史记录来生成一个隐含的上下文变量 ϕi，以帮助策略在未来表现更好。</p><p>在强化学习中，不同于监督学习，适应过程不仅仅是对已知数据进行调整，还需要决定如何与环境交互，特别是选择那些能够帮助模型快速适应的新动作。这也意味着元强化学习需要设计有效的探索策略，以便更好地适应环境的变化。</p><p>接下来，我们假设模型是一个循环神经网络（RNN），用于读取一系列状态-动作-奖励的转换序列，并将其编码为隐藏向量 hi​。像之前在监督学习中的做法一样，我们在新任务上使用 hi ​ 进行预测，结合状态 s 生成策略 πϕi(a∣s)。这里，ϕi 是由 hi 和参数 θπ​ 组成的，用于描述特定任务的上下文。</p><p>换句话说，θπ表示上下文策略的参数，而 θ∗ 是查看转换序列的编码器的参数，用于推断正确的上下文 hi。这个模型是一个非常基础的元学习算法，RNN 的隐藏状态 hi 作为上下文，θπ是经过元学习得到的权重，形成了一个自适应的上下文策略模型。</p><p></p><p></p><p></p><p>在实际工作当中，我们只需要训练一个rnn策略，这里有个例子，有一个只有四种状态的网格世界，老鼠的目标是获取奶酪，只有上下左右四种行动可以选择，假设我们已经完成了meta training ，我们来了解一下适应过程的实际情况，在这里老鼠最初并不知道奶酪在哪里，所以它可能会选择任意的一个行动，但是这里经过了meta learning，在此过程中老鼠学会了一些合理的探索策略，所以老鼠最初可能会向右移动，然后会在历史记录里加入一组数据（S1 A1 S2 R1）（左下角 向右走 新状态右下角 奖励0），在这个位置，老鼠有可能会采取向左的动作，所以在向左走之后，又会在历史记录里加入新的记录（），然后在这个位置，episode结束了。也就是说我们的episode只有2，老鼠需要在两个时间步内吃到奶酪。Episode结束之后， 老鼠会被重置为初始的状态，但是rnn的隐藏状态仍然存在，所以rnn并不是在每个episode之后都会重置。在新的episode中，（蓝色所示）因为老鼠有记忆，他知道奶酪不在右下角，所以它会选择不同的动作，这次老鼠向上移动，然后新的记录被加入了历史记录里面，在那个位置时，老鼠也许回采取向右走，但是不是因为他知道奶酪在那里，这里的策略是一种可能性的探索策略，走到右边之后，他获得了奖励。然后因为过了两个时间步，老鼠又重置回到了初始状态，但因为rnn的隐藏状态一直存在，（如黄色所示）所以老鼠会直接采取向上的动作，紧接着采取向右的动作。</p><p></p><p>Why recurrent policies learn to explore</p><p>当我们在整个meta-episode上优化RNN策略的回报时，模型自动学会了探索的策略。这是因为，RNN策略需要在初期探索环境来找到最佳的行动方案，而这个过程无需额外显式编码探索行为，而是通过优化目标自然学到的。</p><p></p><p>首先，我想先来点背景知识，这不是强化学习（RL）特有的内容。假设我们暂时不考虑之前关于元学习的讨论，回到有监督的计算机视觉任务。在计算机视觉和自然语言处理这些领域，一种常见的方法是拿一个大数据集，比如ImageNet或者大型文本语料库之类的，去训练一个有很多参数的大模型。然后我们可以从这个模型中提取特征，用它的前几层作为特征提取器，然后在这些特征之上加一个新的小型神经网络，对它进行微调，用来解决你可能没有太多数据的下游任务。</p><p>举个例子，如果你想训练一个鸟类细分类器，你可以先用ImageNet训练一个大的卷积网络，然后砍掉最后的全连接层，把卷积层拿来作为特征提取器。接着，你可以在这个基础上微调一个新的网络，用来处理你自己小规模的鸟类数据集。</p><p>这个过程叫做预训练和微调。其实它解决的问题跟元学习非常相似，因为我们在利用先前任务的数据来帮助自己更高效地学习新任务，尽管在这里只有一个先前任务。</p><p>那么，预训练算不算元学习的一种呢？其实还不完全是，因为在预训练中，我们并没有特别去优化模型让它更适合微调。事实上，预训练的效果往往依赖于数据集的选择，比如用ImageNet来预训练就很适合鸟类任务，但用MNIST数字数据集来预训练就不行，因为数字跟鸟类没什么相似之处。</p><p>那么，如果我们可以把预训练变成一种元学习呢？如果我们能通过某种方式来预训练，使得网络经过优化后能够更高效地微调到新任务上会怎么样？这其实会让我们获得更好的特征，从而更快地学习新任务。</p><p></p><p>Meta-RL as an optimization problem P17</p><p>这是我们的通用的meta-rl问题，我们必须从经验中改进策略并进行探索。那么如果f theta Mi本身就是一个RL算法，我们可以说这是一个策略梯度算法。在标准RL中，我们会发现，theta star 是相对于预期奖励的theta的argmax，我们这个目标称为j theta，然后我们可以说标准的rl算法将重复的计算新的参数向量theta k+1，这个向量由theta k给出，加上学习率alpha乘以j theta k的theta k梯度，这就是基本的策略梯度。回到左边这个问题上，我们将f theta本身设为RL算法，就可以写成这种形式，现在用它来计算theta梯度和Ji theta，需要与Mi进行交互才能估计梯度，又因为mi的f theta是mi的函数并允许去交互。这就是模型不可知meta learning背后的思想，将mi的f theta定义为关于mdp mi的目标Ji theta上一个或多个梯度步骤。</p><p></p><p>MAML for RL in pictures</p><p></p><p>这可能通过图片更容易理解。假设我们有一个策略参数 θ\thetaθ，这是我们的元学习参数。我们正在进行常规的强化学习任务，我们会生成一系列episode，比如在这个例子中，我们正在让机器人学习向右跑，我们将使用这些episode来计算梯度，进行更新，来得到更好的参数theta 撇。但是现在我们在不同的batch当中有多个不同的任务，我们计算梯度的方式是将theta 设置为theta加上meta learning学习率beta乘以多个任务的梯度总和，这个梯度是相对于该任务回报的theta。我们通过在每个任务上执行一次梯度更新得到一个参数向量，因此meta learning的目标是在theta加alpha乘以grad theta ji theta处进行评估。这样做的目的是让模型学到的theta能通过一次策略梯度更新使该任务的表现达到最佳效果。因此，meta 策略梯度实际上包含一个二阶导数。</p><p>当然，如果愿意的话，可以在多个梯度步骤中进行更新。</p><p>可以将其直观地理解为：如果标记为 θ的粗线表示元优化路径，你会尝试将参数 θ放在这样一个位置，使得每个任务的一个梯度更新步骤（用 ∇L 箭头表示）尽可能接近各自的最优参数，用 θ1∗ ​、θ2∗​ 和 θ3∗ 表示的那些任务的最佳参数。乍一看这有些奇怪，但实际上非常有意义，因为这样一来，除了已有的策略参数外，不需要额外的参数。没有额外的神经网络，只是在训练你的策略参数，使它们能够尽可能高效地适应新任务。</p><p></p><p>What did we just do??</p><p>不过，如果我们回到meta学习的基本概念，监督学习的流程是将 f(x) 应用于 x，得到 y。在监督meta学习中，我们则将 f 应用到训练数据集 Dtr 和输入 x 上，以得到 y。模型不可知的meta学习与此类似，只不过我们使用的是函数 fMAML，将其应用于训练集 Dtr 和 x，或在强化学习的情境下应用于环境 M 和状态 S。</p><p>这个函数 fMAML ​有一个特别的形式：在监督学习中，它通过对损失函数进行梯度下降来更新参数θ′，即 fMAML(Dtr,x)=fθ′(x)，其中 θ′是通过一步梯度更新得到的。同理，在强化学习中，可以在期望奖励上使用梯度上升步骤来更新。</p><p>可以将这个过程视为一个计算图。因此，如果不确定梯度下降的细节，可以简单地将其理解为另一个计算流程，并使用你偏好的自动微分工具实现。虽然在策略梯度更新时需要谨慎，以确保计算的导数正确，但本质上它只是另一种结构。</p><p>这种结构的优势在于它可能具有有利的归纳偏置，因为假设你的强化学习算法是原则性明确且整体优化的，它应当能提升你的奖励。例如，RNN在一些极端任务上可能无法很好地泛化，而强化学习算法在最坏的情况下至少不会比从零开始学习差，因为它是在新任务上通过策略梯度进行学习。</p><p></p><p>Meta-RL as… partially observed RL?</p><p></p><p>接下来，我们要讨论如何把元强化学习构建成一个“部分观察的马尔可夫决策过程”，简称POMDP。</p><p>一开始，这个思路可能听上去有点奇怪，但其实元强化学习确实可以被视作一个部分观察的MDP。通常的MDP包括状态空间、动作空间、转移概率和奖励，而POMDP在这基础上增加了观察空间 O 和初始分布 E，用于描述在给定状态下观察到某些值的概率。</p><p>这里有一个部分观察MDP的图示。我的观点是，元强化学习其实跟常规的强化学习类似，但在POMDP的框架下进行。假设你有一组不同的元训练MDP，比如从 M1 到 Mn。我们想构建一个部分观察的MDP，使得在这个MDP中最大化奖励的过程，就像是在适应一个新的完全观察的MDP一样。</p><p>那要怎么实现呢？简单来说，我们需要构建一个部分观察的MDP，主要选择的部分包括状态、观察、发射概率和动态转移。动作空间我们其实不用改变，因为动作空间是一致的。核心问题在于，怎么把一个元强化学习问题嵌入到POMDP里去。</p><p>在POMDP中，策略是基于观察 o 来行动的，这通常需要显式的状态估计。也就是说，我们可能会有一个独立的状态估计器，根据过去的观察序列估计 st的概率 p(st∣o1:t)。或者，我们可以使用带有记忆的策略。之前我们在讨论RNN时也提到过带记忆的策略，这里就很有用。</p><p>在元强化学习的情境下，我们可以用这种方式来理解这个构建思路。</p><p></p><p>在Meta-RL中，我们的策略可以表示为 πθ(a∣s,z)，其中 s 是状态，z 封装了完成当前任务所需的信息。之前我们用 ϕ 表示这个变量，但在这里改用 z，后面我们会看到这样做的原因。</p><p>如果将学习任务视为推断 z 的过程，那么我们可以通过观察任务的上下文信息（如状态、动作、奖励的序列）来推断出当前任务的 z 值。这样一来，Meta-RL的构建就类似于一个POMDP。</p><p></p><p>在构建这个POMDP时，我们定义了新的状态空间 S~=S×Z，其中 S 是原始状态空间，Z 表示推断出的任务信息。同时，新的观察空间 O~仅包含原始状态空间中的 S。也就是说，虽然我们无法直接观测到 z，但可以通过观察状态 s 和奖励来推断它。</p><p>解决POMDP问题实际上等价于元学习，因为要完成当前任务，我们需要显式或隐式地找出 z 的值。我们可以通过带有记忆的策略（比如循环神经网络）来自动执行这个元学习过程，从而更有效地适应新任务。</p><p>不过，这种方法并不是最佳选择，因为POMDP比传统的MDP复杂得多。要解决POMDP，我们可以进行显式的状态估计，比如通过变分推理来学习近似的后验分布，对 z 进行采样，并根据采样结果进行探索。</p><p>这个过程的关键在于后验采样策略。我们可以根据过去的状态、动作和奖励分布来估计 z，并将其作为一种探索策略。尽管这并不是最优解，因为它无法收集足够的信息来进一步优化任务识别过程，但在理论和实践中都证明这种方法是有效的。</p><p></p><p>Variational inference for meta-RL</p><p>好的，接下来是一个真正应用了这个思路的算法。这就是 PERL算法，这个算法使用了变分推理来学习 p^​。</p><p>在这个方法里，我们有一个策略 πθ(at∣st,zt)，还有一个推理网络 qϕ(zt∣states, actions, rewards)，通过状态、动作和奖励的历史来推断 zt。</p><p>训练策略参数 θ 和推理网络参数 ϕ 的目标是最大化策略 πθ​ 在使用 qϕ ​ 获得的 z 时的期望奖励，同时最小化 q(z) 和先验 p(z)) 之间的 KL 散度。这个目标基于变分下界，确保推理的稳定性。</p><p>这个方法和我们之前讲的控制推理非常类似，更新后的奖励和标准的元强化学习相同，同时保持接近先验分布，确保 q 能捕捉到分布中的不确定性。在概念上，这个方法和 RNN 的元强化学习非常相似，但这里的 z 是随机的，通过后验采样来实现探索。</p><p></p><p>在实例化这种算法时，我们需要选择一个合适的架构来构建 qϕ(zt)，这个架构需要基于历史信息。就像 RNN 的元学习过程一样，有很多不同的架构选择，理论上都可以有效工作。</p><p>在这篇论文中使用的特定架构，是通过编码器对每个状态转换 (s, a, s', r) 进行编码，然后以一种不受排列顺序影响的方式将这些特征平均，从而得到一个最终的分布。这里有一个有趣的点，那就是在上下文的历史中，我们其实不需要关注转换的顺序，因为在每个 MDP 内部，马尔可夫属性成立，这意味着顺序并不重要。</p><p>这种并行编码器架构相比于 RNN 有其独特优势，因为你不需要进行长时间的反向传播。每个转换仅与最终结果相隔一步，因此反向传播路径会短很多。这虽然主要是架构的一个细节，但确实在实践中有帮助。</p><p>然后，当然你需要选择一个 RL 算法来执行最大化过程。PEARL 使用的是软行动者评论家（SAC），但你也可以选择其他算法，比如策略梯度方法。</p><p>最后，这是论文中的一些实验结果。可以看到，这种方法表现得非常好，当然其中涉及了很多实现细节，影响了这种性能表现。</p><p></p><p>The three perspectives on meta-RL</p><p>在结束本节之前，回顾一下我们之前讨论过的元强化学习的三个视角，或者说至少是无模型元强化学习的三个视角。这三个视角可以通过一个通用的图示来概括：我们要思考 fθ(Mi) 实际上应该做什么。它需要通过经验来改进策略，还要学会如何探索。我们看到的视角包括：</p><p>视角一：使用标准强化学习算法训练一个大型 RNN，其中每个元情节都会跨越多个独立的情节。</p><p>视角二：双层优化视角，这种视角帮助我们引入了 MAML（模型无关的元学习）算法。</p><p>视角三：将其视为一个推断问题，把问题建模为一个 POMDP（部分观测马尔可夫决策过程），并学习如何推断 zzz，即完成任务所需的上下文信息。</p><p></p><p>RNN 视角在概念上非常简单，也比较容易应用，但它有一些缺点，比如容易导致元过拟合。RNN 是一种非常强大的模型，但如果元训练数据集规模不够大或者不够多样化——这种情况在强化学习中非常常见——模型就可能会发生元过拟合。这意味着它在回忆元训练任务时表现良好，但在处理新任务时泛化能力可能不足。</p><p>双层优化视角则有一些优势。它具有很好的外推性，这种一致性意味着即使新任务与元训练任务有所不同，模型通过RL或策略梯度，最终也能学会新任务。尽管加速效果不如分布内任务显著，但这是一个在概念上很优雅的框架，利用了很多优化的理论基础，使我们更好地理解这些方法的有效性。不过，由于涉及二阶导数，这种方法实现起来比较复杂，并且可能需要大量样本来训练。</p><p>推理问题视角则相对简单且有效。通过后验采样，它在探索方面表现良好，这种将问题简化为解决特殊POMDP的方式，为设计新算法提供了有力工具。但它也像RNN方法一样，容易出现元过拟合。同时，由于方差和噪声的增加，使得优化和实际应用具有挑战性。</p><p></p><p>话虽如此，这三种视角在很多方面其实没有那么不同。视角三基本上就是视角一，只是引入了随机隐藏变量。如果我们不考虑POMDP连接的复杂性，你可以把视角三看作是把原来的变量ϕ重命名为z，并加了一些噪声。</p><p>视角二在某些方面只是对视角一或三的一种特定架构选择。你可以使用RNN，也可以使用并行编码器，或者添加一个梯度步骤。在某些情况下，这只是不同架构的选择。</p><p></p><p>Model-Based Meta-RL</p><p></p><p>Meta learning的最后一部分，我们来讨论基于模型的元强化学习。到目前为止，我们讨论的都是无模型的方法，而基于模型的设置在很多方面其实更简单，因为许多用于监督元学习的思路也可以应用于元模型的训练。在基于模型的元强化学习中，和标准的基于模型设置非常相似，我们会从主要关注策略训练转向更多关注模型训练。通过积累一些经验来改进模型，从而间接提升策略。</p><p>基于模型的强化学习的基本步骤是：先收集一些数据，然后用这些数据来得到状态转移模型的近似，接着使用这个模型进行规划。这些方法同样适用于学习策略的基于模型的强化学习算法，但目前我们关注的只是基于模型进行规划的强化学习。使用基于模型的方法的一个重要原因是它比无模型方法需要的数据要少得多，尤其是在元训练阶段。无模型的元强化学习算法可能在适应上效率很高，但在元训练阶段依旧需要大量资源，而使用模型可以缓解这一问题。</p><p>此外，基于模型的元强化学习算法在理论上可以适应得更快。因为无模型的方法最终是通过观察奖励来调整，而基于模型的元强化学习则可以仅通过观察模型预测误差来进行调整。这意味着即便还没得到实际的奖励反馈，模型已经可以根据对下一个状态预测的准确性来进行自我修正和适应。</p><p></p><p>我们讨论一个基于模型的元强化学习示例，展示了任务或情境可能在单个情节中发生变化的情况。假设你有一个蚂蚁机器人，在某个时刻它的一条腿断了。原本适用于四条腿的行走方式现在行不通了，因为它只有三条功能完好的腿。如果能快速调整模型，它仍然可以继续行走。</p><p>非自适应方法的步骤是：收集一些数据片段，然后训练一个模型来预测状态转移，之后利用这个模型优化动作选择，比如通过规划完成。</p><p>而自适应方法则是每执行一步，就观察当前状态、动作和下一个状态，并据此更新模型。可以使用与模型无关的元学习方法或RNN等方法，然后利用更新后的模型来优化接下来的动作。实际上，如果愿意的话，甚至可以在每一个时间步都调整模型。</p><p>但是，如果没有元训练，仅仅天真地采取这些梯度更新，可能无法在一步中完成有效适应。所以没有元训练的自适应方法并不适用于深度网络。它可以在简单的模型上有效，比如线性模型，这也是自适应控制领域关注的问题。但对于深度神经网络模型，仅凭一个样本很难做出大幅调整。然而，通过元学习，我们在元测试时可以实现更有效的适应性调整。</p><p></p><p>在元测试时，我们会采用这种自适应过程，但在训练时，我们会构建一个元训练集，就像在监督学习中那样。就像我们在讲座开头看到的Ravi和Lara Shell的图示一样，元训练集包含多个训练集和测试集。</p><p>接下来要解决的问题是，我们如何构建这个元训练集。一旦构建好它，我们就可以使用任何有监督的元学习算法来进行训练，包括模型无关的元学习方法、RNN方法或其他任何方法，然后在测试时用于适应。因此，真正需要弄清楚的是如何在训练时构建它们。元训练集由一组训练-测试子集组成，我们在训练时通过在D_train上进行适应，来调整我们的适应过程，以便适应后的模型在D_test上表现良好。</p><p>这里，x表示(s, a)，y表示s'，所以我们可以生成每个D_train和D_test。具体操作是从过去的经验中随机抽取一些子序列，从s_t到s_t+k。假设我们过去的经验包含了许多不同的动态，比如可能之前我们见过腿断了的情况，或在不同地形上移动的情况。我们并不需要知道任务的边界，只是随机抽取这些子序列，然后定义D_train为从s_t到s_t+k-1的部分，而D_test是最后一个时间步的转换，即(s_t+k, a_t+k, s_t+k+1)。</p><p>我们可以选择k=1，但k大于1效果更好，比如k=5。这样，我们就能在从D_train适应后，在D_test上得到较好的结果。如果有一条长的轨迹，我们可以选择其中的一段作为D_train，后续的部分作为D_test。这样做的好处是，这种构建方式和元测试时的情况非常相似：在元测试时，我们会获得一个或多个步骤的数据，然后需要在后续步骤中表现良好。</p><p>通过这种训练方式，我们在元测试时能获得较好的效果。比如在这里断腿的任务中，使用经过元训练的模型后，一旦检测到腿断了，模型能够迅速适应，帮助完成任务。</p><p></p><p></p><p></p><h2>lec23</h2><p></p><p>主要讨论深度强化学习领域中的一些挑战和未解决的问题，同时分享一些关于如何使用深度强化学习方法，以及在该领域进行研究的实用建议。</p><p>首先，让我们来看一下深度强化学习中的一些关键挑战，主要包括核心算法和基本假设两方面的问题：</p><p>稳定性：你的算法是否能够收敛？是否可以对算法的行为做出任何保证？</p><p>效率：算法收敛需要多长时间？需要多少样本？计算资源的需求有多大？</p><p>泛化能力：算法收敛后，得到的策略模型或价值函数能否有效地泛化，适应新的场景？</p><p>除此之外，强化学习的基本假设也带来了挑战。如果我们希望将强化学习应用于现实世界场景，就需要重新审视这些假设。例如，强化学习的基本问题设定是否适合基于学习的控制任务？在强化学习中，监督的来源应该是什么？这些问题都需要进一步思考和研究。</p><p></p><p>首先，让我们谈谈在深度强化学习中的一些核心挑战，包括算法的稳定性和超参数调节。你的算法是否能够成功收敛？设计稳定的强化学习算法是非常困难的，每类算法都有自己特有的问题。</p><p>以 Q 学习和价值函数估计为例。使用深度神经网络逼近的拟合 Q 值方法通常无法保证收敛，导致我们必须费力调整超参数以获得好的效果。例如，我们需要调整目标网络延迟、回放缓冲区大小、梯度裁剪、学习率等，这样才能让算法学习出有效的 Q 函数和价值函数。</p><p>此外，政策梯度或 REINFORCE 方法也面临挑战。尽管理论上它们是无偏的梯度估计，但在实践中存在高方差的问题，导致需要大量样本和精细的学习率调整，才能确保稳定的性能。我们还需要优化批量大小、学习率、基准设计等超参数。</p><p>在基于模型的强化学习算法中，还有一系列更复杂的设计决策，例如选择合适的模型类别、拟合方法、模型架构等。这些决策会显著影响算法的稳定性和性能。同时，优化模型下的策略并不容易，例如反向传播时间问题或生成合成轨迹时会继承无模型算法的缺点。此外，策略在模型下可能倾向于“利用”模型缺陷，从而生成不现实的行为，这也为实际应用带来了挑战。</p><p></p><p></p><p>如果你想在现实世界中应用强化学习，显然无法像在实验中那样进行超参数扫描，因为不可能让真实系统运行几十次来验证哪种参数效果最好。不过，你可以考虑使用模拟器来调整参数。至于模拟器的代表性，通常并不是很高，但可能足够接近实际情况，让你能先在模拟器上调整超参数，然后再将优化后的参数应用到真实系统中。</p><p>如果你依赖于超参数扫面并且所有工作都在模拟环境中进行，那么你需要注意，算法的实际样本复杂度等于算法运行时间乘以扫描中的运行次数。可以把它看作是一种元强化学习算法，结合了随机搜索或超参数优化和基于梯度的优化。实际上，一些研究人员已经提出了这一过程作为一种算法，通常在超参数优化上使用无导数优化，灵感源自进化算法和遗传算法。</p><p>另外，我们还可以探索开发对超参数不那么敏感的、更稳定的算法，这是当前一个活跃的研究领域。如果你希望在深度强化学习领域产生影响，开发对超参数不敏感的算法无疑是一个非常重要且有价值的方向。</p><p></p><p>那么，我们能做些什么？我们可以尝试设计具有良好改进和收敛特性的算法。例如，一些研究表明，在某些限制性假设下，算法可以提供改进的保证。在讨论策略梯度时，我提到了基于“信任区域策略优化”（Trust Region Policy Optimization）的保证。此外，还有关于“安全强化学习”和“高置信度策略改进”的研究。如果你对此感兴趣，可以参考Philip Thomas的一些工作。</p><p>另外，还有一些算法可以自适应地调整参数类型，例如Gu等人在Q-Prop论文中提出的方法，通过控制变量或基线与回报的相关性，自适应调整其强度。</p><p>不过，这方面还需要更多的研究。通常，在深度强化学习研究中（尤其是在学术领域），研究人员更关注渐近性能的改进，而不是算法的简单性和超参数的敏感性。因为性能改进可以被测量并展示在图表中，而提高超参数的鲁棒性和降低敏感性则相对较难展示，因为这涉及到与已经调优的其他方法的对比。</p><p>希望正在考虑研究深度强化学习的你，不会被这些挑战所吓退。减少超参数数量、自动化调参过程以及降低对超参数的敏感性，是使深度强化学习真正实用的重要方向。虽然这些改进对击败基准性能并没有直接帮助，但对于使强化学习成为解决现实世界问题的可行工具却至关重要。</p><p></p><p>为了使强化学习在现实问题中成为一种可行的工具，简化和稳定算法是必不可少的。接下来我们来探讨样本复杂性。</p><p>在这个幻灯片中，我将展示不同方法的样本复杂性对比，逐步从最耗费样本的方法讲到最节省样本的方法。首先，我们来看那些需要最多样本的无梯度方法。这类算法用于强化学习目标时完全不需要反向传播。接下来是完全在线的算法，例如A3C，这类方法在策略上进行一步并立即更新。然后是批处理模式的策略梯度方法，如TRPO和PPO，它们会采样多个轨迹后再进行更新。之后是基于重播缓冲的离策略算法，例如Q学习、DDPG、NAF和SAC，这类方法利用离线的策略数据进行学习。</p><p>再往下是基于模型的深度强化学习算法，如PETS和引导策略搜索。这些方法能够更快地学习。而在底部，我们有基于模型的浅层方法，如PILCO，这些方法不使用神经网络，而是采用高斯过程等更高效的函数逼近器。</p><p>举个例子，像进化策略这样的无梯度方法通常需要多10倍的样本才能达到与下一层方法相似的效果。A3C方法在“半猎豹”任务中需要约1亿步，换算下来相当于连续运行15天左右。TRPO在稍微复杂的“半猎豹”任务上需要约1000万步，大约1.5天的实时训练时间。而对于DDPG等离策略方法，这个任务的时间需求缩短至约3小时。基于模型的深度强化学习方法则进一步缩短了时间，例如PETS可能只需要几分钟。基于模型的浅层方法甚至可以在几秒内学到任务，但这种方法的计算成本非常高，且在复杂任务上容易受到维度限制。</p><p>需要注意的是，不同方法在样本效率上存在10倍的差异，这只是一个粗略的估计，适用于那些所有方法都能表现良好的任务。对于样本获取非常便宜或者可以并行计算的任务，例如棋类游戏或简单物理模拟时，样本效率较低的方法可能更具优势，因为它们并行计算能力强，能更快得出结果。</p><p>对于一些基于离策略值的方法，虽然样本复杂性较低，但计算成本较高。例如，DDPG和SAC在训练时，生成样本和执行计算的时间接近甚至超过了样本收集时间。对于极端情况下的浅层方法，如PILCO，样本所需时间虽然很短，但计算时间却可能长得多。因此，虽然它们在样本数量上效率高，但计算时间却可能超过一个小时。</p><p>综上所述，虽然在实际应用中选择方法时我们会考虑样本效率，但计算成本也是不容忽视的因素。在某些情况下，即便样本效率较低的方法，也能通过并行计算获得较快的结果。因此，选择适合的方法时，应权衡样本复杂性和计算成本，以确保在现实场景中更好地满足需求。</p><p></p><p>样本复杂性带来的挑战主要体现在以下几个方面：</p><p>首先，高样本复杂性会导致训练过程耗时过长。在实验环境中，这意味着作业完成需要等待很长时间，而在真实场景中，这种延迟会让强化学习的应用变得困难，甚至不切实际。例如，如果要训练一个控制化工厂或机器人的策略，需要连续数天的运算时间，这在实际操作中可能完全无法实现，因为训练过程需要配套的安全机制和人工监督。</p><p>其次，高样本复杂性限制了高成本、高精度模拟器的使用。虽然我们可以利用高端有限元方法等模拟器来模拟复杂现象，但这些模拟器的运行速度通常比实时还要慢，导致强化学习无法在其上有效执行。这种情况在高端模拟器中非常普遍，极大地限制了强化学习在实际问题中的应用。</p><p>因此，如何有效解决样本复杂性问题是一个重要的课题。如果我们能在保持算法有效性的同时减少样本需求，将大大提升强化学习在真实世界中应用的可行性。</p><p></p><p>我们可以采取哪些措施来应对样本复杂性的问题呢？</p><p>改进基于模型的强化学习算法：通过开发更好的模型来提高样本利用效率，加快学习速度，从而在实际应用中减少对大量样本的依赖。</p><p>设计更快的算法：例如，在离策略强化学习领域，已有许多方法尝试通过不同的技巧来加速算法，如DDPG风格的算法。此外，Soft Actor-Critic（SAC）是一种高效的最大熵强化学习算法，也是离策略方法之一。在该领域还有许多其他研究都致力于加速算法的执行效率。</p><p>重用先验知识：可以通过多种方式利用已有的知识来加速强化学习过程。例如，使用元学习（Meta-Learning）技术，通过在不同任务中的学习经验来快速适应新任务；也可以使用离线强化学习（Offline Reinforcement Learning）算法，借助已有的数据或相关任务的知识，从而减少所需样本量，加速强化学习过程。</p><p>这些方法有助于缓解样本复杂性带来的挑战，从而让强化学习更高效、更易于在现实世界中应用。</p><p></p><p>在这一部分中，我们来探讨深度强化学习（Deep RL）的扩展性和泛化能力。深度强化学习从一开始就备受关注，部分原因在于它的潜力：结合强化学习算法的优势（学习接近最优的行为和控制策略），以及深度学习的强大泛化能力。例如，当我们在类似ImageNet这样的大型数据集上训练一个高容量的卷积神经网络时，模型对新图像的泛化效果会非常好。</p><p>然而，许多使用大数据集的监督学习任务通常是大规模任务，强调多样性和泛化能力的评估。相对而言，强化学习的研究大多集中在小规模任务上，更注重掌握程度，通常以最终奖励来衡量算法的表现。这意味着强化学习算法的评价标准往往并不是其泛化能力，而是它在训练过程中获得的最终奖励。</p><p>举个稍显夸张的例子，这种做法就好比我们用一张图像的分类信心度来评估图像分类器，认为置信度高的分类器更好，然而在图像分类任务中，真正重要的是分类器能否对未见过的新图像给出正确答案，而不是对训练数据中的图像置信度高低。对于强化学习来说，这种测试方式显然并不理想，因为我们常常是在“训练集”上进行测试，而非真正的泛化测试。</p><p>因此，如果我们真正追求泛化，那么仅仅关注表现可能不是最佳选择。一个疑问是，强化学习的泛化能力究竟如何体现？我们又该如何提升这种能力？ 实际上，在泛化问题上，强化学习面临着巨大挑战。</p><p></p><p>问题可以这样理解。在监督学习中，我们的工作流程相对简单：首先从现实世界收集数据，但这一步通常只需要进行一次。数据收集完成后，我们将其保存到磁盘中，可以反复使用这些数据。然后，通过这些数据，我们可以多轮次地训练模型，同时使用验证集来评估模型的表现。一旦对模型的效果满意，就可以将其部署到现实世界中使用。</p><p>而在强化学习中，流程则复杂得多。我们有一个智能体（agent），需要不断地与环境交互，收集数据、改进策略。每次改进之后，智能体都必须再次进行交互，重复这一过程，不断更新策略，才能逐步学习出一个最优的解决方案。这种频繁的数据采集和策略更新，使得强化学习在实际应用中面临更大的挑战。</p><p></p><p>在强化学习中，智能体需要多次重复交互，收集数据并不断改进策略。这种过程的循环，使得使用大数据集变得相当困难。因为如果希望智能体更新其模型，往往需要为每次实验重新收集数据。即使使用非策略算法，通常每次实验也需要额外的数据。</p><p>但实际上，强化学习的情况比这理想化的图景更加复杂，因为在实际的强化学习中，还存在一个外层循环。这个外层循环的主体是算法设计者，比如研究生、本科生或研究人员。他们需要不断修改算法、调整超参数，进行变更和优化，以使算法效果更好。这一外层循环围绕着整个迭代过程，使得即便强化学习在理论上可以多次迭代和收集大数据集，在实际中因调试和调整算法的工作量巨大，这一过程变得完全不切实际。</p><p></p><p>作为替代方案，我们不仅仅需要关注离策略的强化学习（off-policy RL），而是需要深入研究类似于离线强化学习（offline RL）的方法。正如在他的演讲中所讨论的那样，我们可以记录来自过去交互的大型数据集，只在偶尔情况下收集一些新的数据。这样实际上进入了离线强化学习算法的领域，尤其当我们希望在不重新收集新数据的前提下进行算法的调优和设计时，离线 RL 显得尤为重要。这也是为什么离策略 RL 和更极端的离线 RL 变得如此重要的原因，当然这不仅仅适用于强化学习的某些特定领域。</p><p></p><p>不只是机器人领域。在很多领域中，这些问题更加严峻。比如在自动驾驶领域，尽管可以轻松从人类驾驶员的数据中获取大量的历史交互数据，但要让自动驾驶汽车在美国各个城市中轮流测试并在每次策略更新后进行重新训练，几乎是不现实的。</p><p>语言和对话系统也是类似的情况，虽然可以获得丰富的历史语言数据，但要获取大量实时的在线交互数据却非常困难。</p><p>在其他领域，如运营研究、金融、物流、库存管理等，实现有效的泛化能力通常需要大量的数据支持。这些数据虽然确实存在，但要在部分训练的强化学习策略下主动在线收集这些数据，却非常具有挑战性。</p><p></p><p>到目前为止，我讨论了一些与核心算法和强化学习相关的挑战。关键在于，如果我们保持强化学习的原有问题定义，那么我们会面临哪些挑战？以及我们如何开始思考解决这些问题。在讲座的下一部分，我将讨论一组更基础的挑战，这些挑战与强化学习方法中所做的假设有关，无论这些方法的效果如何。首先，让我们来谈谈问题的本质。</p><p></p><p>首先，我们来谈谈问题的描述。我们在设定强化学习问题时，需要解决一些核心问题。其中一个问题是：我们想要解决的是单任务问题，还是多任务问题？正如我之前提到的，现实世界并非那么简单，它具有高度的多样性和变化性，而这种复杂性正是我们希望实现泛化能力的来源。</p><p>实际上，RL问题的传统描述基本上是围绕单任务进行的。虽然我们可以通过构建一个融合的马尔可夫决策过程（MDP）将多个MDP合并为一个，从而扩展到多任务场景，但多任务学习对我们期望的泛化效果来说至关重要。因此，我们或许应该更明确地将多任务学习纳入强化学习的框架中，比如在测试阶段，系统会遇到训练时从未见过的新MDP。</p><p>在这种情况下，RL的基本问题描述可能显得有些局限。通常情况下，我们认为每个回合会从一个随机选择的初始状态开始，测试阶段也会给出一个随机初始状态。然而，这种方式可能不够理想，因为它意味着只要训练时间足够长，就能遇到所有的情况。但实际上，我们可能更希望有一个“训练集”和一个“测试集”，或者找到一种其他方法，将对未见过情况的泛化作为首要目标。</p><p>因此，也许不需要重新定义问题，但这个差异确实值得进一步关注。如果你正在考虑重新思考强化学习问题的描述，不妨思考单任务和多任务学习的差异，以及它们对泛化效果的影响。</p><p></p><p>在多任务学习的泛化方面，可以考虑以下几种方法：</p><p>首先，可以通过对多个任务进行训练，再进行微调来实现泛化。这类似于我们在迁移学习课程中讨论的方法。我们在课程中也提到了一些相关的引用和研究。</p><p>另一种方法是对多样化行为进行无监督或弱监督学习。例如，在预训练阶段可以接触到各种各样的情况，之后在微调阶段可以利用在无监督阶段学到的知识，在更狭窄的环境中学习新任务，并能够推广到更多种类的情境中。这种方法类似于监督学习领域中的无监督预训练。</p><p>此外，还有一些研究论文探讨了这一方法的变体。在信息理论探索课程中，我们也详细讨论了这一点。这可能是重新思考问题设定的一种方式，有助于更好地解决泛化问题。</p><p>这仍然是一个开放的研究领域，目前没有明确的答案，但可以作为一个潜在的探索方向。</p><p></p><p>下一个问题是，在强化学习中监督来自哪里？</p><p>在监督学习中，监督的来源非常清楚，系统会告诉你给定输入的正确标签或正确输出。而在强化学习中，监督的来源是什么呢？</p><p>简而言之，监督来自奖励函数，但同时也受到我们在设置马尔可夫决策过程（MDP）时所做的许多其他设计决策的影响。如果你希望系统能够学习许多不同的任务，你需要从某处获取这些任务，可能在选择行动层面上不需要精细的监督，但对每个任务的奖励级别需要有一定的监督。</p><p>在某些环境中，监督来源相对简单，比如视频游戏中可以很直观地设定奖励，但在其他环境中则复杂得多。例如，如果想通过强化学习让机器人学会倒水，光是判断杯子是否装满水就是个难题。如果我们想用强化学习来训练一个充当治疗师的聊天机器人，虽然看起来像是一个可以解决的机器学习任务，但如何定义“有效的治疗”本身几乎和生成对话文本一样困难。</p><p>也许我们可以通过逆强化学习的演示来学习目标或奖励，以解决这一问题，或者我们可以像在无监督学习讨论中那样自动生成目标。但如果我们退一步，用更基础的方式思考奖励函数在强化学习中的作用，我们可能希望奖励函数的作用是告诉智能体该做什么。</p><p></p><p>奖励函数的作用是告诉智能体“做什么”，但在实际应用中，奖励函数往往不仅需要指定目标，还需要指引“怎么做”。就像我们在课程中提到的那样，奖励函数有时需要更加细致地设计，才能帮助智能体学习完成任务的过程。</p><p>比如，在一个行走任务中，我们可能会设想一个简单的奖励规则：智能体成功行走就得到奖励，否则没有。然而，实际情况中，我们往往需要更复杂的奖励设计，比如根据智能体的速度、躯干是否保持直立等多种因素给予不同的奖励。你们在作业中遇到的奖励机制也是类似的，设计得相当精细。</p><p>有人可能会认为这是因为当前的强化学习方法还不够完美，导致我们不得不设计复杂的奖励机制，但实际上，人脑中的奖励机制也并非简单。大脑中的基底神经节并不像一些描述那样，只有“吃到美食获得好奖励，否则得到坏奖励”的简单反应。基底神经节中的奖励机制非常复杂。</p><p>想象猎豹捕猎瞪羚的情景。如果猎豹只能在成功捕猎后获得奖励，那么它的学习过程会非常困难，因为随机捕到猎物的机会极低。如果在第一次成功捕猎前，猎豹无法感知到这种行为的奖励，那么它很可能永远无法掌握这一技能。因此，一个复杂的奖励机制是有必要的。</p><p>在强化学习中，我们可以将这种复杂性视为算法问题，通过开发更能适应复杂奖励的算法来解决这一挑战。但我们也可以从根本上思考：奖励机制的本质应该是什么？这种反思可能会帮助我们重新设计和优化强化学习的奖励系统。</p><p></p><p>我们可以重新思考奖励机制的设计。或许可以尝试无监督强化学习，即在没有明确奖励函数的情况下与环境互动，探索可能的行为和可以达成的目标，然后将这种知识应用到新的任务中。通过无奖励的互动，我们可以更好地理解环境，为未来的任务提供基础。</p><p>这种无监督探索不仅是一种有效的知识获取方式，也有助于广泛应用到新任务中。当然，这只是解决问题的一个方向。</p><p>另外，我们也可以考虑其他可能的监督来源，以更全面地探讨和应对这一挑战。</p><p></p><p>当我们重新思考强化学习问题的表述时，有许多方面值得我们重新审视。我们可以思考如何定义控制问题，是将其定义为“最大化奖励”，还是采用数据驱动的方式，亦或是定义为“匹配某种观察到的行为”？数据是什么？目标是什么？监督是什么？监督是否等同于目标，还是有其他形式的监督，比如奖励和一些示范？这些都是值得考虑的合理选择。</p><p>在定义控制问题时保持开放的心态是很有必要的。重要的是要思考哪种假设最符合问题的背景条件。无模型的标准强化学习表述是否适合当前问题？还是说，有其他方式可能更简单，或者能提供更有效的信息？</p><p>此外，不要将强化学习问题的基本表述视为一成不变的。重新思考问题表述，考虑哪种表述可能更易处理、更具扩展性，或者更适用于你所关注的问题情境。</p><p></p><p></p><p>在本课程的第一堂课中，提到可以将学习视为智能的基础，也许我们可以把强化学习看作一种机制，使我们能够推理和决策。深度模型让强化学习算法能够学习并表达复杂的输入与输出映射，深度模型和强化学习结合起来，使得算法可以端到端地解决复杂问题。</p><p></p><p>为了在现实环境中表现智能，一个系统需要获得足够的信息，无论推理能力多强，如果对世界一无所知，也无法表现出智能。所以，从某种粗略的角度来看，训练智能机器的问题就变成了向计算机填充足够的信息的问题。</p><p>过去十年来，数据驱动的方法展现了这一观点的合理性——通过大量数据，系统可以识别各种边缘情况、异常情况等。当世界难以用简洁的规则描述时，就需要大量的信息来理解各种情况。</p><p>不同学习方式的信息密度各不相同。在监督学习中，每个标签可能只包含少量的信息，比如在 ImageNet 中，每个标签大约有 10 位的信息。如果有一百万张图像，总共大约有 1000 万位的信息，也就是 10 兆字节。</p><p>在强化学习中，监督的信息密度可能更低。特别是在稀疏奖励的情况下，每个样本可能几乎没有信息，因此监督的密度可能非常低。然而，在无监督学习中，比如预测未来图像的任务中，每个样本可以包含数百万位的信息密度。</p><p>因此，若要实现真正的智能机器，就需要无监督或预测学习方法，因为它们能够提供更高的信息密度。无监督学习虽然不提供人类的知识标签，但它能让系统观察世界，学习物理规律、因果关系和宇宙结构。</p><p>这可能引发一些深思——也许我们可以通过无监督学习的方式，让系统从世界中获取大量观察性知识。</p><p></p><p>奖励机制和监督信号在强化学习中可能有多种来源。首先，无监督学习的观点认为，模型通过观察性知识从与环境的互动中学习，这种知识涵盖了物理、因果关系、宇宙结构等广泛内容。该观点认为，若要实现智能机器的目标，我们需要通过无监督或自监督学习提供密集的信息，使模型在尚未达到特定目标或获得奖励之前就积累丰富的认知。</p><p>另一种观点认为，监督不仅来自于环境的物理属性，还可能源自其他智能体的行为。我们能够驾驶汽车、制造飞机、使用计算机，或许并非全因个体智力的卓越，而是因为我们生活在一个社会环境中，通过模仿和理解他人行为而获得丰富的监督信号，从而在合理的样本复杂度下实现有意义的行为学习。</p><p>此外，强化学习的奖励信号可能并不稀缺，相反，它可能提供了大量的信息。当奖励通过系统中的动态状态传播，并与状态转换结合时，会形成一个丰富的监督来源。因此，预测哪个状态具有高价值是一个复杂的问题，而价值函数将动态与奖励结合，提供了深层次的监督信号。该观点认为，只需改进基本强化学习方法，就有可能在有限的监督下实现丰富的学习效果。</p><p>综上所述，或许答案在于整合以上各种监督来源。这意味着问题的复杂性可能要求多种监督来源的协同作用：无监督学习与预测、对其他智能体的模仿理解、以及强大的基本强化学习算法，以从有限的奖励中提取丰富的监督信号。</p><p></p><p>在本次最后，还有一些问题。首先，我们在强化学习中需要选择正确的问题。不要过分依赖基准任务，因为强化学习本质上是一个结合了优化和机器学习的特殊领域。在优化中，我们强调如何更好地解决优化问题，而在机器学习中，我们则更注重泛化能力。当前的许多强化学习基准任务实际上是优化任务，但现实世界中的复杂性和多样性并不一定能够通过这些基准任务来代表。因此，我们应该考虑那些具有代表性的现实世界问题，它们或许并不是机器人技术的典型应用，而是包括对话生成、物流运营、医疗保健、教育等数据驱动的强化学习问题。选择这些正确的问题能够确保我们的算法创新有潜力去解决这些实际存在的复杂问题。</p><p>此外，要关注生成模型、预测及其他机器学习领域的进展，而不仅仅局限于强化学习算法。强化学习的下一次重大创新很可能来自于引入其他领域的思想，改变我们对问题的看法，调整我们的假设或问题表述，或带来新的算法思路，这些在几十年的强化学习研究中尚未被充分探索。</p><p>我们还需要深刻理解强化学习与其他领域之间的关系。在某些层面上，强化学习其实与分布匹配、处理分布变化等机器学习的其他领域并无太大差异。理解这些相同点和不同点有助于我们将新的思维方式引入强化学习研究。</p><p></p></article></body></html></article>
                    </article>
                
            
        </div>
    </div>
</div>

    </div>

    <!-- 页脚 -->
    <footer class="bg-light py-4 mt-4">
        <div class="container text-center">
            <p class="mb-0">Free &amp; Inspiration</p>
            <p class="mb-0 mt-2">
                <small class="text-muted">
                    &copy; 2025 由paiHomeBlog-开源Blog系统生成
                    
                </small>
            </p>
        </div>
    </footer>

    <!-- JavaScript -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    
<!-- 代码高亮 -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js/styles/github.min.css">
<script src="https://cdn.jsdelivr.net/npm/highlight.js/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>



</body>
</html> 